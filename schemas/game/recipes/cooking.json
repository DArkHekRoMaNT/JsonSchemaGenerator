{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "CookingRecipe",
  "type": "object",
  "properties": {
    "code": {
      "type": "string"
    },
    "ingredients": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/CookingRecipeIngredient"
      }
    },
    "enabled": {
      "type": "boolean"
    },
    "shape": {
      "$ref": "#/definitions/CompositeShape"
    },
    "perishableProps": {
      "$ref": "#/definitions/TransitionableProperties"
    }
  },
  "definitions": {
    "CookingRecipeIngredient": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "The code for the recipe ingredient."
        },
        "minQuantity": {
          "type": "integer",
          "description": "The minimum quantity required for the given ingredient.",
          "format": "int32"
        },
        "maxQuantity": {
          "type": "integer",
          "description": "The maximum quantity required for the given ingredient.",
          "format": "int32"
        },
        "world": {
          "description": "The world accessor for the ingredient.",
          "oneOf": [
            {
              "$ref": "#/definitions/IWorldAccessor"
            }
          ]
        },
        "validStacks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CookingRecipeStack"
          }
        }
      }
    },
    "IWorldAccessor": {
      "type": "object",
      "description": "Important interface to access the game world.",
      "x-abstract": true,
      "properties": {
        "config": {
          "type": "array",
          "description": "The current world config",
          "items": {}
        },
        "defaultSpawnPosition": {
          "description": "The default spawn position as sent by the server (usually the map middle). Does not take player specific spawn point into account",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityPos"
            }
          ]
        },
        "frameProfiler": {
          "description": "Gets the frame profiler utility.",
          "oneOf": [
            {
              "$ref": "#/definitions/FrameProfilerUtil"
            }
          ]
        },
        "api": {
          "description": "The api interface",
          "oneOf": [
            {
              "$ref": "#/definitions/ICoreAPI"
            }
          ]
        },
        "claims": {
          "description": "The land claiming api interface",
          "oneOf": [
            {
              "$ref": "#/definitions/ILandClaimAPI"
            }
          ]
        },
        "loadedChunkIndices": {
          "type": "array",
          "description": "Returns a list all loaded chunk positions in the form of a long index. Code to turn that into x/y/z coords:\nVec3i coords = new Vec3i(\n   (int)(chunkIndex3d % ChunkMapSizeX),\n   (int)(chunkIndex3d / (ChunkMapSizeX * ChunkMapSizeZ)),\n   (int)((chunkIndex3d / ChunkMapSizeX) % ChunkMapSizeZ)\n);\nRetrieving the list is not a very fast process, not suggested to be called every frame",
          "items": {
            "type": "integer",
            "format": "int64"
          }
        },
        "loadedMapChunkIndices": {
          "type": "array",
          "description": "Returns a list all loaded chunk positions in the form of a long index",
          "items": {
            "type": "integer",
            "format": "int64"
          }
        },
        "blockLightLevels": {
          "type": "array",
          "description": "The currently configured block light brightness levels",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "sunLightLevels": {
          "type": "array",
          "description": "The currently configured sun light brightness levels",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "seaLevel": {
          "type": "integer",
          "description": "The currently configured sea level (y-coordinate)",
          "format": "int32"
        },
        "seed": {
          "type": "integer",
          "description": "The world seed. Accessible on the server and the client",
          "format": "int32"
        },
        "savegameIdentifier": {
          "type": "string",
          "description": "A globally unique identifier for this savegame"
        },
        "sunBrightness": {
          "type": "integer",
          "description": "The currently configured max sun light level",
          "format": "int32"
        },
        "entityDebugMode": {
          "type": "boolean",
          "description": "Whether the current side (client/server) is in entity debug mode"
        },
        "assetManager": {
          "description": "Loaded game assets",
          "oneOf": [
            {
              "$ref": "#/definitions/IAssetManager"
            }
          ]
        },
        "logger": {
          "description": "Logging Utility",
          "oneOf": [
            {
              "$ref": "#/definitions/ILogger"
            }
          ]
        },
        "side": {
          "description": "The current side (client/server)",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumAppSide"
            }
          ]
        },
        "blockAccessor": {
          "description": "Access blocks and other world data from loaded chunks, fault tolerant",
          "oneOf": [
            {
              "$ref": "#/definitions/IBlockAccessor"
            }
          ]
        },
        "bulkBlockAccessor": {
          "description": "Fault tolerant bulk block access to the worlds block data. Since this is a single bulk block access instance the cached data is shared for everything accessing this method, hence should only be accessed from the main thread and any changed comitted within the same game tick. You can however use the WorldManager api to get your own instance of a bulk block accessor",
          "oneOf": [
            {
              "$ref": "#/definitions/IBulkBlockAccessor"
            }
          ]
        },
        "classRegistry": {
          "description": "Interface to create instance of certain classes",
          "oneOf": [
            {
              "$ref": "#/definitions/IClassRegistryAPI"
            }
          ]
        },
        "calendar": {
          "description": "Interface to access the game calendar. On the server side only available after run stage 'LoadGamePre' (before that it is null)",
          "oneOf": [
            {
              "$ref": "#/definitions/IGameCalendar"
            }
          ]
        },
        "collisionTester": {
          "description": "For collision testing in the main thread",
          "oneOf": [
            {
              "$ref": "#/definitions/CollisionTester"
            }
          ]
        },
        "rand": {
          "description": "Just a random number generator. Makes use of ThreadLocal for thread safety.",
          "oneOf": [
            {
              "$ref": "#/definitions/Random"
            }
          ]
        },
        "elapsedMilliseconds": {
          "type": "integer",
          "description": "Amount of milliseconds ellapsed since startup",
          "format": "int64"
        },
        "collectibles": {
          "type": "array",
          "description": "List of all loaded blocks and items without placeholders",
          "items": {
            "$ref": "#/definitions/CollectibleObject"
          }
        },
        "blocks": {
          "type": "array",
          "description": "List of all loaded blocks. The array index is the block id. Some may be null or placeholders (then block.code is null).",
          "items": {
            "$ref": "#/definitions/Block"
          }
        },
        "items": {
          "type": "array",
          "description": "List of all loaded items. The array index is the item id. Some may be null or placeholders (then item.code is null)",
          "items": {
            "$ref": "#/definitions/Item"
          }
        },
        "entityTypes": {
          "type": "array",
          "description": "List of all loaded entity types. ",
          "items": {
            "$ref": "#/definitions/EntityProperties"
          }
        },
        "gridRecipes": {
          "type": "array",
          "description": "List of all loaded crafting recipes",
          "items": {
            "$ref": "#/definitions/GridRecipe"
          }
        },
        "alloys": {
          "type": "array",
          "description": "List of all loaded metal alloys",
          "items": {
            "$ref": "#/definitions/AlloyRecipe"
          }
        },
        "cookingRecipes": {
          "type": "array",
          "description": "List of all loaded cooking recipes",
          "items": {
            "$ref": "#"
          }
        },
        "smithingRecipes": {
          "type": "array",
          "description": "List of all loaded smithing recipes",
          "items": {
            "$ref": "#/definitions/SmithingRecipe"
          }
        },
        "knappingRecipes": {
          "type": "array",
          "description": "List of all loaded knapping recipes",
          "items": {
            "$ref": "#/definitions/KnappingRecipe"
          }
        },
        "clayFormingRecipes": {
          "type": "array",
          "description": "List of all loaded clay forming recipes",
          "items": {
            "$ref": "#/definitions/ClayFormingRecipe"
          }
        },
        "barrelRecipes": {
          "type": "array",
          "description": "List of all loaded barrel recipes",
          "items": {
            "$ref": "#/definitions/BarrelRecipe"
          }
        },
        "defaultEntityTrackingRange": {
          "type": "integer",
          "description": "The range in blocks within a client will receive regular updates for an entity",
          "format": "int32"
        },
        "allOnlinePlayers": {
          "type": "array",
          "description": "Gets a list of all online players. ",
          "items": {
            "$ref": "#/definitions/IPlayer"
          }
        },
        "allPlayers": {
          "type": "array",
          "description": "Gets a list of all players that connected to this server at least once. When called client side you will receive the same as AllOnlinePlayers",
          "items": {
            "$ref": "#/definitions/IPlayer"
          }
        },
        "interesectionTester": {
          "description": "Utility for testing intersections. Only access from main thread.",
          "oneOf": [
            {
              "$ref": "#/definitions/AABBIntersectionTest"
            }
          ]
        }
      }
    },
    "EntityPos": {
      "type": "object",
      "description": "Represents all positional information of an entity, such as coordinates, motion and angles",
      "properties": {
        "motion": {
          "$ref": "#/definitions/Vec3d"
        },
        "x": {
          "type": "number",
          "description": "The X position of the Entity.",
          "format": "double"
        },
        "y": {
          "type": "number",
          "description": "The Y position of the Entity.",
          "format": "double"
        },
        "z": {
          "type": "number",
          "description": "The Z position of the Entity.",
          "format": "double"
        },
        "roll": {
          "type": "number",
          "description": "The rotation around the X axis, in radians.",
          "format": "float"
        },
        "yaw": {
          "type": "number",
          "description": "The rotation around the Y axis, in radians.",
          "format": "float"
        },
        "pitch": {
          "type": "number",
          "description": "The rotation around the Z axis, in radians.",
          "format": "float"
        },
        "stance": {
          "type": "integer",
          "format": "int32"
        },
        "asBlockPos": {
          "description": "Returns the position as BlockPos object",
          "oneOf": [
            {
              "$ref": "#/definitions/BlockPos"
            }
          ]
        },
        "xyzInt": {
          "description": "Returns the position as a Vec3i object",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3i"
            }
          ]
        },
        "xyz": {
          "description": "Returns the position as a Vec3d object",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "xyzFloat": {
          "description": "Returns the position as a Vec3f object",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        }
      }
    },
    "Vec3d": {
      "type": "object",
      "description": "Represents a vector of 3 doubles. Go bug Tyron of you need more utility methods in this class.",
      "properties": {
        "x": {
          "type": "number",
          "format": "double"
        },
        "y": {
          "type": "number",
          "format": "double"
        },
        "z": {
          "type": "number",
          "format": "double"
        },
        "asBlockPos": {
          "$ref": "#/definitions/BlockPos"
        },
        "xInt": {
          "type": "integer",
          "format": "int32"
        },
        "yInt": {
          "type": "integer",
          "format": "int32"
        },
        "zInt": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "BlockPos": {
      "type": "object",
      "description": "A useful data structure when operating with block postions.\nValuable Hint: Make use of Copy() or the XXXCopy() variants where needed. A common pitfall is writing code like: BlockPos abovePos = pos.Up(); - with this code abovePos and pos will reference to the same object!",
      "properties": {
        "x": {
          "type": "integer",
          "format": "int32"
        },
        "y": {
          "type": "integer",
          "format": "int32"
        },
        "z": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Vec3i": {
      "type": "object",
      "description": "Represents a vector of 3 ints. Go bug Tyron if you need more utility methods in this class.",
      "properties": {
        "x": {
          "type": "integer",
          "format": "int32"
        },
        "y": {
          "type": "integer",
          "format": "int32"
        },
        "z": {
          "type": "integer",
          "format": "int32"
        },
        "asBlockPos": {
          "$ref": "#/definitions/BlockPos"
        }
      }
    },
    "Vec3f": {
      "type": "object",
      "description": "Represents a vector of 3 floats. Go bug Tyron of you need more utility methods in this class.",
      "properties": {
        "x": {
          "type": "number",
          "description": "The X-Component of the vector",
          "format": "float"
        },
        "y": {
          "type": "number",
          "description": "The Y-Component of the vector",
          "format": "float"
        },
        "z": {
          "type": "number",
          "description": "The Z-Component of the vector",
          "format": "float"
        },
        "r": {
          "type": "number",
          "description": "Synonum for X",
          "format": "float"
        },
        "g": {
          "type": "number",
          "description": "Synonum for Y",
          "format": "float"
        },
        "b": {
          "type": "number",
          "description": "Synonum for Z",
          "format": "float"
        }
      }
    },
    "FrameProfilerUtil": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean"
        },
        "printSlowTicks": {
          "type": "boolean"
        },
        "printSlowTicksThreshold": {
          "type": "integer",
          "format": "int32"
        },
        "elemsPrevFrame": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int64"
          }
        },
        "summary": {
          "type": "string"
        },
        "ellapsedMs": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "ICoreAPI": {
      "type": "object",
      "description": "Common API Components that are available on the server and the client. Cast to ICoreServerAPI or ICoreClientAPI to access side specific features.",
      "x-abstract": true,
      "properties": {
        "logger": {
          "description": "The local Logger instance.",
          "oneOf": [
            {
              "$ref": "#/definitions/ILogger"
            }
          ]
        },
        "cmdlArguments": {
          "type": "array",
          "description": "The command line arguments that were used to start the client or server application",
          "items": {
            "type": "string"
          }
        },
        "side": {
          "description": "Returns if you are currently on server or on client",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumAppSide"
            }
          ]
        },
        "event": {
          "description": "Api component to register/trigger events",
          "oneOf": [
            {
              "$ref": "#/definitions/IEventAPI"
            }
          ]
        },
        "world": {
          "description": "Second API Component for access/modify everything game world related",
          "oneOf": [
            {
              "$ref": "#/definitions/IWorldAccessor"
            }
          ]
        },
        "classRegistry": {
          "description": "API Compoment for creating instances of certain classes, such as Itemstacks",
          "oneOf": [
            {
              "$ref": "#/definitions/IClassRegistryAPI"
            }
          ]
        },
        "network": {
          "description": "API for sending/receiving network packets",
          "oneOf": [
            {
              "$ref": "#/definitions/INetworkAPI"
            }
          ]
        },
        "assets": {
          "description": "API Component for loading and reloading one or multiple assets at once from the assets folder",
          "oneOf": [
            {
              "$ref": "#/definitions/IAssetManager"
            }
          ]
        },
        "modLoader": {
          "description": "API Component for checking for and interacting with other mods and mod systems",
          "oneOf": [
            {
              "$ref": "#/definitions/IModLoader"
            }
          ]
        }
      }
    },
    "ILogger": {
      "type": "object",
      "description": "Interface to the client's and server's event, debug and error logging utilty.",
      "x-abstract": true,
      "properties": {
        "traceLog": {
          "type": "boolean",
          "description": "If true, will also print to Diagnostics.Debug."
        }
      }
    },
    "EnumAppSide": {
      "type": "string",
      "description": "",
      "x-enumFlags": true,
      "x-enumNames": [
        "Server",
        "Client",
        "Universal"
      ],
      "enum": [
        "server",
        "client",
        "universal"
      ]
    },
    "IEventAPI": {
      "type": "object",
      "description": "Events that are available on the server and the client",
      "x-abstract": true
    },
    "IClassRegistryAPI": {
      "type": "object",
      "description": "Interface for creating instances",
      "x-abstract": true,
      "properties": {
        "blockClassToTypeMapping": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "itemClassToTypeMapping": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "INetworkAPI": {
      "type": "object",
      "x-abstract": true
    },
    "IAssetManager": {
      "type": "object",
      "description": "Takes care loading, reloading and managing all files inside the assets folder. All asset names and paths are always converted to lower case.",
      "x-abstract": true,
      "properties": {
        "allAssets": {
          "type": "object",
          "description": "All assets found in the assets folder",
          "additionalProperties": {
            "$ref": "#/definitions/IAsset"
          }
        },
        "origins": {
          "type": "array",
          "description": "Returns all origins in the priority order. Highest (First) to Lowest (Last)",
          "items": {
            "$ref": "#/definitions/IAssetOrigin"
          }
        }
      }
    },
    "IAsset": {
      "type": "object",
      "description": "Represents a loaded asset from the assets folder",
      "x-abstract": true,
      "properties": {
        "name": {
          "type": "string",
          "description": "The assets Filename "
        },
        "location": {
          "type": "string",
          "description": "The AssetLocation of the asset."
        },
        "origin": {
          "description": "The origin informaton of the asset.",
          "oneOf": [
            {
              "$ref": "#/definitions/IAssetOrigin"
            }
          ]
        },
        "data": {
          "type": "string",
          "description": "The file contents in binary format",
          "format": "byte"
        }
      }
    },
    "IAssetOrigin": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "originPath": {
          "type": "string"
        }
      }
    },
    "IModLoader": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "mods": {
          "type": "array",
          "description": "Gets a collection of all enabled mods.",
          "items": {
            "$ref": "#/definitions/Mod"
          }
        },
        "systems": {
          "type": "array",
          "description": "Gets a collection of all loaded and enabled mod systems.",
          "items": {
            "$ref": "#/definitions/ModSystem"
          }
        }
      }
    },
    "Mod": {
      "type": "object",
      "description": "Represents a mod in the mod manager. May contain zero to multiple\nModSystem instances within it.",
      "x-abstract": true,
      "properties": {
        "sourceType": {
          "description": "Gets the origin file type of the mod (.cs, .dll, .zip or folder). ",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumModSourceType"
            }
          ]
        },
        "sourcePath": {
          "type": "string",
          "description": "Gets the full path to where this mod originated from, including file name. "
        },
        "fileName": {
          "type": "string",
          "description": "Gets the file name of this mod. "
        },
        "info": {
          "description": "Gets the info of this mod. Found either as \"modinfo.json\" in the\nof the mod's folder or archive, or in the case of raw .cs and .dll\nfiles, using the ModInfoAttribute\non the assembly.",
          "oneOf": [
            {
              "$ref": "#/definitions/ModInfo"
            }
          ]
        },
        "worldConfig": {
          "$ref": "#/definitions/ModWorldConfiguration"
        },
        "icon": {
          "type": "string",
          "description": "Holds the icon of this mod. Found as \"modicon.png\" in the root of\nthe mod's folder or archive. May be null."
        },
        "logger": {
          "description": "Gets the logger associated with this mod. ",
          "oneOf": [
            {
              "$ref": "#/definitions/ILogger"
            }
          ]
        },
        "systems": {
          "type": "array",
          "description": "Gets a collection of systems belonging to this mod. ",
          "items": {
            "$ref": "#/definitions/ModSystem"
          }
        }
      }
    },
    "EnumModSourceType": {
      "type": "string",
      "description": "Represents the origin file type of the mod.",
      "x-enumNames": [
        "CS",
        "DLL",
        "ZIP",
        "Folder"
      ],
      "enum": [
        "cs",
        "dll",
        "zip",
        "folder"
      ]
    },
    "ModInfo": {
      "type": "object",
      "description": "Meta data for a specific mod folder, archive, source file or assembly.\nEither loaded from a \"modinfo.json\" or from the assembly's\nModInfoAttribute.",
      "properties": {
        "type": {
          "description": "The type of this mod. Can be \"Theme\", \"Content\" or \"Code\". ",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumModType"
            }
          ]
        },
        "textureSize": {
          "type": "integer",
          "description": "If the mod is a texture pack that changes topsoil grass textures, define the texture size here",
          "format": "int32"
        },
        "name": {
          "type": "string",
          "description": "The name of this mod. For example \"My Example Mod\". "
        },
        "version": {
          "type": "string",
          "description": "The version of this mod. For example \"2.10.4\". (optional) "
        },
        "networkVersion": {
          "type": "string",
          "description": "The network version of this mod. Change this number when a user that has an older version of your mod should not be allowed to connected to server with a newer version. If not set, the version value is used."
        },
        "description": {
          "type": "string",
          "description": "A short description of what this mod does. (optional) "
        },
        "website": {
          "type": "string",
          "description": "Location of the website or project site of this mod. (optional) "
        },
        "modID": {
          "type": "string",
          "description": "The mod id (domain) of this mod. For example \"myexamplemod\".\n(Optional. Uses mod name (converted to lowercase, stripped of\nwhitespace and special characters) if missing.)"
        },
        "authors": {
          "type": "array",
          "description": "Names of people working on this mod. (optional) ",
          "items": {
            "type": "string"
          }
        },
        "contributors": {
          "type": "array",
          "description": "Names of people contributing to this mod. (optional) ",
          "items": {
            "type": "string"
          }
        },
        "side": {
          "description": "Which side(s) this mod runs on. Can be \"Server\", \"Client\" or \"Universal\".\n(Optional. Universal (both server and client) by default.)",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumAppSide"
            }
          ]
        },
        "requiredOnClient": {
          "type": "boolean",
          "description": "If set to false and the mod is universal, clients don't need the mod\nto join. (Optional. True by default.)"
        },
        "requiredOnServer": {
          "type": "boolean",
          "description": "If set to false and the mod is universal, the mod is not disabled\nif it's not present on the server. (Optional. True by default.)"
        },
        "dependencies": {
          "type": "array",
          "description": "List of mods (and versions) this mod depends on. ",
          "items": {
            "$ref": "#/definitions/ModDependency"
          }
        }
      }
    },
    "EnumModType": {
      "type": "string",
      "description": "Describes the type of a mod. Allows easy recognition and limiting of\nwhat any particular mod can do.",
      "x-enumNames": [
        "Theme",
        "Content",
        "Code"
      ],
      "enum": [
        "theme",
        "content",
        "code"
      ]
    },
    "ModDependency": {
      "type": "object",
      "description": "Represents a mod dependency requirement of one mod for another.",
      "properties": {
        "modID": {
          "type": "string",
          "description": "The required mod id (domain) of this dependency. "
        },
        "version": {
          "type": "string",
          "description": "The minimum version requirement of this dependency.\nMay be empty if the no specific version is required."
        }
      }
    },
    "ModWorldConfiguration": {
      "type": "object",
      "properties": {
        "playStyles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PlayStyle"
          }
        },
        "worldConfigAttributes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WorldConfigurationAttribute"
          }
        }
      }
    },
    "PlayStyle": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string"
        },
        "playListCode": {
          "type": "string"
        },
        "langCode": {
          "type": "string"
        },
        "listOrder": {
          "type": "number",
          "format": "double"
        },
        "mods": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "worldType": {
          "type": "string"
        },
        "worldConfig": {
          "$ref": "#/definitions/JsonObject"
        }
      }
    },
    "JsonObject": {
      "type": "object",
      "description": "Elegant, yet somewhat inefficently designed (because wasteful with heap objects) wrapper class to abstract away the type-casting nightmare of JToken O.O",
      "properties": {
        "exists": {
          "type": "boolean",
          "description": "True if the token is not null"
        },
        "token": {}
      }
    },
    "WorldConfigurationAttribute": {
      "type": "object",
      "properties": {
        "dataType": {
          "$ref": "#/definitions/EnumDataType"
        },
        "code": {
          "type": "string"
        },
        "min": {
          "type": "number",
          "format": "double"
        },
        "max": {
          "type": "number",
          "format": "double"
        },
        "step": {
          "type": "number",
          "format": "double"
        },
        "onCustomizeScreen": {
          "type": "boolean"
        },
        "default": {
          "type": "string"
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "onlyDuringWorldCreate": {
          "type": "boolean"
        },
        "typedDefault": {}
      }
    },
    "EnumDataType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Bool",
        "IntInput",
        "DoubleInput",
        "IntRange",
        "String",
        "DropDown"
      ],
      "enum": [
        "bool",
        "intInput",
        "doubleInput",
        "intRange",
        "string",
        "dropDown"
      ]
    },
    "ModSystem": {
      "type": "object",
      "description": "Base of a system, which is part of a code mod. Takes care of setting up,\nregistering and handling all sorts of things. You may choose to split up\na mod into multiple distinct systems if you so choose, but there may\nalso be just one.",
      "x-abstract": true,
      "properties": {
        "mod": {
          "description": "Gets the Mod this mod system is part of.",
          "oneOf": [
            {
              "$ref": "#/definitions/Mod"
            }
          ]
        },
        "allowRuntimeReload": {
          "type": "boolean",
          "description": "When the server reloads mods at runtime, should this mod also be reloaded. Return false e.g. for any mod that adds blocks."
        }
      }
    },
    "ILandClaimAPI": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "all": {
          "type": "array",
          "description": "List of all claims on the server. Same as WorldManager.SaveGame.Claims.",
          "items": {
            "$ref": "#/definitions/LandClaim"
          }
        }
      }
    },
    "LandClaim": {
      "type": "object",
      "properties": {
        "areas": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Cuboidi"
          }
        },
        "protectionLevel": {
          "type": "integer",
          "format": "int32"
        },
        "ownedByEntityId": {
          "type": "integer",
          "format": "int64"
        },
        "ownedByPlayerUid": {
          "type": "string"
        },
        "ownedByPlayerGroupUid": {
          "type": "integer"
        },
        "lastKnownOwnerName": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "permittedPlayerGroupIds": {
          "type": "object",
          "description": "Other groups allowed to use this land",
          "additionalProperties": {
            "$ref": "#/definitions/EnumBlockAccessFlags"
          }
        },
        "permittedPlayerUids": {
          "type": "object",
          "description": "Other players allowed to use this land",
          "additionalProperties": {
            "$ref": "#/definitions/EnumBlockAccessFlags"
          }
        },
        "permittedPlayerLastKnownPlayerName": {
          "type": "object",
          "description": "Other players allowed to use this land, name of the player at the time the privilege was granted",
          "additionalProperties": {
            "type": "string"
          }
        },
        "allowUseEveryone": {
          "type": "boolean"
        },
        "center": {
          "$ref": "#/definitions/BlockPos"
        },
        "sizeXZ": {
          "type": "integer",
          "format": "int32"
        },
        "sizeXYZ": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Cuboidi": {
      "type": "object",
      "properties": {
        "x1": {
          "type": "integer",
          "format": "int32"
        },
        "y1": {
          "type": "integer",
          "format": "int32"
        },
        "z1": {
          "type": "integer",
          "format": "int32"
        },
        "x2": {
          "type": "integer",
          "format": "int32"
        },
        "y2": {
          "type": "integer",
          "format": "int32"
        },
        "z2": {
          "type": "integer",
          "format": "int32"
        },
        "minX": {
          "type": "integer",
          "format": "int32"
        },
        "minY": {
          "type": "integer",
          "format": "int32"
        },
        "minZ": {
          "type": "integer",
          "format": "int32"
        },
        "maxX": {
          "type": "integer",
          "format": "int32"
        },
        "maxY": {
          "type": "integer",
          "format": "int32"
        },
        "maxZ": {
          "type": "integer",
          "format": "int32"
        },
        "sizeX": {
          "type": "integer",
          "format": "int32"
        },
        "sizeY": {
          "type": "integer",
          "format": "int32"
        },
        "sizeZ": {
          "type": "integer",
          "format": "int32"
        },
        "sizeXYZ": {
          "type": "integer",
          "format": "int32"
        },
        "sizeXZ": {
          "type": "integer",
          "format": "int32"
        },
        "start": {
          "$ref": "#/definitions/Vec3i"
        },
        "end": {
          "$ref": "#/definitions/Vec3i"
        },
        "center": {
          "$ref": "#/definitions/Vec3i"
        },
        "volume": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "EnumBlockAccessFlags": {
      "type": "string",
      "description": "",
      "x-enumFlags": true,
      "x-enumNames": [
        "None",
        "BuildOrBreak",
        "Use"
      ],
      "enum": [
        "none",
        "buildOrBreak",
        "use"
      ]
    },
    "IBlockAccessor": {
      "type": "object",
      "description": "Provides read/write access to the blocks of a world",
      "x-abstract": true,
      "properties": {
        "chunkSize": {
          "type": "integer",
          "description": "Width, Length and Height of a chunk",
          "format": "int32"
        },
        "regionSize": {
          "type": "integer",
          "description": "Width and Length of a region in blocks",
          "format": "int32"
        },
        "mapSizeX": {
          "type": "integer",
          "description": "X Size of the world in blocks",
          "format": "int32"
        },
        "mapSizeY": {
          "type": "integer",
          "description": "Y Size of the world in blocks",
          "format": "int32"
        },
        "mapSizeZ": {
          "type": "integer",
          "description": "Z Size of the world in blocks",
          "format": "int32"
        },
        "regionMapSizeX": {
          "type": "integer",
          "format": "int32"
        },
        "regionMapSizeY": {
          "type": "integer",
          "format": "int32"
        },
        "regionMapSizeZ": {
          "type": "integer",
          "format": "int32"
        },
        "updateSnowAccumMap": {
          "type": "boolean",
          "description": "Whether to update the snow accum map on a SetBlock()"
        },
        "mapSize": {
          "description": "Size of the world in blocks",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3i"
            }
          ]
        }
      }
    },
    "IBulkBlockAccessor": {
      "type": "object",
      "description": "Useful for setting many blocks at once efficiently",
      "x-abstract": true,
      "properties": {
        "readFromStagedByDefault": {
          "type": "boolean",
          "description": "If set to true, the methods GetBlock() and GetBlockId() will behave like GetStagedBlockId() until the next commit"
        }
      }
    },
    "IGameCalendar": {
      "type": "object",
      "description": "Main API for retrieving anything calender or astronomy related",
      "x-abstract": true,
      "properties": {
        "onGetHemisphere": {
          "description": "Assigned by the survival mod. Must return the hemisphere at give location",
          "oneOf": [
            {
              "$ref": "#/definitions/HemisphereDelegate"
            }
          ]
        },
        "onGetSolarAltitude": {
          "description": "Assigned by the survival mod. The calendar uses this method to determine the solar altitude at given location and time. If not set, the calendar uses a default value of about 0.75",
          "oneOf": [
            {
              "$ref": "#/definitions/SolarAltitudeDelegate"
            }
          ]
        },
        "onGetLatitude": {
          "description": "Assigned by the survival mod. Must return the latitude for given position. If not set, the calendar uses a default value of 0.5\n-1 for south pole, 0 for equater, 1 for north pole",
          "oneOf": [
            {
              "$ref": "#/definitions/GetLatitudeDelegate"
            }
          ]
        },
        "speedOfTime": {
          "type": "number",
          "description": "This acts as a multiplier on how much faster an ingame second passes by compared to a real life second. Affects physics, like the motion speed of waving grass. The default is 60, hence per default a day lasts 24 minutes, but it's also multiplied by CalendarSpeedMul which is 0.5 by default so the end result is 48 minutes per day\nThis is the sum of all modifiers",
          "format": "float"
        },
        "calendarSpeedMul": {
          "type": "number",
          "description": "A multiplier thats applied to the progression of the calendar. Set this to 0.1 and a day will last 10 times longer, does not affect physics.",
          "format": "float"
        },
        "hoursPerDay": {
          "type": "number",
          "description": "Amount of hours per day",
          "format": "float"
        },
        "daysPerYear": {
          "type": "integer",
          "description": "Amount of days per year",
          "format": "int32"
        },
        "daysPerMonth": {
          "type": "integer",
          "description": "Amount of days per month",
          "format": "int32"
        },
        "month": {
          "type": "integer",
          "format": "int32"
        },
        "monthName": {
          "$ref": "#/definitions/EnumMonth"
        },
        "fullHourOfDay": {
          "type": "integer",
          "description": "The current hour of the day as integer",
          "format": "int32"
        },
        "hourOfDay": {
          "type": "number",
          "description": "The current hour of the day as decimal ",
          "format": "float"
        },
        "totalHours": {
          "type": "number",
          "description": "Total passed hours since the game has started",
          "format": "double"
        },
        "totalDays": {
          "type": "number",
          "description": "Total passed days since the game has started",
          "format": "double"
        },
        "dayOfYear": {
          "type": "integer",
          "description": "The current day of the year (goes from 0 to DaysPerYear)",
          "format": "int32"
        },
        "dayOfYearf": {
          "type": "number",
          "description": "The current day of the year (goes from 0 to DaysPerYear)",
          "format": "float"
        },
        "year": {
          "type": "integer",
          "description": "Returns the year. Every game begins with 1386",
          "format": "int32"
        },
        "yearRel": {
          "type": "number",
          "description": "Returns the current season in a value of 0 to 1",
          "format": "float"
        },
        "moonPhase": {
          "description": "The current moonphase",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumMoonPhase"
            }
          ]
        },
        "moonPhaseExact": {
          "type": "number",
          "description": "The current moonphase represented by number from 0..8",
          "format": "double"
        },
        "moonPhaseBrightness": {
          "type": "number",
          "description": "The moons current brightness (higher during full moon)",
          "format": "float"
        },
        "moonSize": {
          "type": "number",
          "description": "The moons current size (larger during full moon)",
          "format": "float"
        }
      }
    },
    "HemisphereDelegate": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "MulticastDelegate": {
      "allOf": [
        {
          "$ref": "#/definitions/Delegate"
        },
        {
          "type": "object",
          "x-abstract": true
        }
      ]
    },
    "Delegate": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "_target": {},
        "_methodBase": {},
        "_methodPtr": {
          "$ref": "#/definitions/IntPtr"
        },
        "_methodPtrAux": {
          "$ref": "#/definitions/IntPtr"
        },
        "Method": {
          "$ref": "#/definitions/MethodInfo"
        },
        "Target": {}
      }
    },
    "IntPtr": {
      "type": "object"
    },
    "MethodInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/MethodBase"
        },
        {
          "type": "object",
          "x-abstract": true,
          "properties": {
            "memberType": {
              "$ref": "#/definitions/MemberTypes"
            },
            "returnType": {
              "type": "string"
            },
            "returnParameter": {
              "$ref": "#/definitions/ParameterInfo"
            }
          }
        }
      ]
    },
    "MemberTypes": {
      "type": "string",
      "description": "",
      "x-enumFlags": true,
      "x-enumNames": [
        "Constructor",
        "Event",
        "Field",
        "Method",
        "Property",
        "TypeInfo",
        "Custom",
        "NestedType",
        "All"
      ],
      "enum": [
        "constructor",
        "event",
        "field",
        "method",
        "property",
        "typeInfo",
        "custom",
        "nestedType",
        "all"
      ]
    },
    "ParameterInfo": {
      "type": "object",
      "properties": {
        "parameterType": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "hasDefaultValue": {
          "type": "boolean"
        },
        "defaultValue": {},
        "rawDefaultValue": {},
        "position": {
          "type": "integer",
          "format": "int32"
        },
        "attributes": {
          "$ref": "#/definitions/ParameterAttributes"
        },
        "member": {
          "$ref": "#/definitions/MemberInfo"
        },
        "isIn": {
          "type": "boolean"
        },
        "isOut": {
          "type": "boolean"
        },
        "isLcid": {
          "type": "boolean"
        },
        "isRetval": {
          "type": "boolean"
        },
        "isOptional": {
          "type": "boolean"
        },
        "metadataToken": {
          "type": "integer",
          "format": "int32"
        },
        "customAttributes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CustomAttributeData"
          }
        }
      }
    },
    "ParameterAttributes": {
      "type": "string",
      "description": "",
      "x-enumFlags": true,
      "x-enumNames": [
        "None",
        "In",
        "Out",
        "Lcid",
        "Retval",
        "Optional",
        "HasDefault",
        "HasFieldMarshal",
        "Reserved3",
        "Reserved4",
        "ReservedMask"
      ],
      "enum": [
        "none",
        "in",
        "out",
        "lcid",
        "retval",
        "optional",
        "hasDefault",
        "hasFieldMarshal",
        "reserved3",
        "reserved4",
        "reservedMask"
      ]
    },
    "MemberInfo": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "customAttributes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CustomAttributeData"
          }
        },
        "metadataToken": {
          "type": "integer",
          "format": "int32"
        },
        "module": {
          "$ref": "#/definitions/Module"
        }
      }
    },
    "CustomAttributeData": {
      "type": "object",
      "properties": {
        "attributeType": {
          "type": "string"
        },
        "constructor": {
          "$ref": "#/definitions/ConstructorInfo"
        },
        "constructorArguments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CustomAttributeTypedArgument"
          }
        },
        "namedArguments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CustomAttributeNamedArgument"
          }
        }
      }
    },
    "ConstructorInfo": {
      "allOf": [
        {
          "$ref": "#/definitions/MethodBase"
        },
        {
          "type": "object",
          "x-abstract": true,
          "properties": {
            "memberType": {
              "$ref": "#/definitions/MemberTypes"
            }
          }
        }
      ]
    },
    "MethodBase": {
      "allOf": [
        {
          "$ref": "#/definitions/MemberInfo"
        },
        {
          "type": "object",
          "x-abstract": true,
          "properties": {
            "methodImplementationFlags": {
              "$ref": "#/definitions/MethodImplAttributes"
            },
            "callingConvention": {
              "$ref": "#/definitions/CallingConventions"
            },
            "isGenericMethodDefinition": {
              "type": "boolean"
            },
            "containsGenericParameters": {
              "type": "boolean"
            },
            "isGenericMethod": {
              "type": "boolean"
            },
            "isSecurityCritical": {
              "type": "boolean"
            },
            "isSecuritySafeCritical": {
              "type": "boolean"
            },
            "isSecurityTransparent": {
              "type": "boolean"
            },
            "isPublic": {
              "type": "boolean"
            },
            "isPrivate": {
              "type": "boolean"
            },
            "isFamily": {
              "type": "boolean"
            },
            "isAssembly": {
              "type": "boolean"
            },
            "isFamilyAndAssembly": {
              "type": "boolean"
            },
            "isFamilyOrAssembly": {
              "type": "boolean"
            },
            "isStatic": {
              "type": "boolean"
            },
            "isFinal": {
              "type": "boolean"
            },
            "isVirtual": {
              "type": "boolean"
            },
            "isHideBySig": {
              "type": "boolean"
            },
            "isAbstract": {
              "type": "boolean"
            },
            "isSpecialName": {
              "type": "boolean"
            },
            "isConstructor": {
              "type": "boolean"
            }
          }
        }
      ]
    },
    "MethodImplAttributes": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "IL",
        "Managed",
        "Native",
        "OPTIL",
        "Runtime",
        "CodeTypeMask",
        "Unmanaged",
        "ManagedMask",
        "NoInlining",
        "ForwardRef",
        "Synchronized",
        "NoOptimization",
        "PreserveSig",
        "AggressiveInlining",
        "SecurityMitigations",
        "InternalCall",
        "MaxMethodImplVal"
      ],
      "enum": [
        "managed",
        "native",
        "optil",
        "codeTypeMask",
        "unmanaged",
        "noInlining",
        "forwardRef",
        "synchronized",
        "noOptimization",
        "preserveSig",
        "aggressiveInlining",
        "securityMitigations",
        "internalCall",
        "maxMethodImplVal"
      ]
    },
    "CallingConventions": {
      "type": "string",
      "description": "",
      "x-enumFlags": true,
      "x-enumNames": [
        "Standard",
        "VarArgs",
        "Any",
        "HasThis",
        "ExplicitThis"
      ],
      "enum": [
        "standard",
        "varArgs",
        "any",
        "hasThis",
        "explicitThis"
      ]
    },
    "CustomAttributeTypedArgument": {
      "type": "object",
      "properties": {
        "argumentType": {
          "type": "string"
        },
        "value": {}
      }
    },
    "CustomAttributeNamedArgument": {
      "type": "object",
      "properties": {
        "memberInfo": {
          "$ref": "#/definitions/MemberInfo"
        },
        "typedValue": {
          "$ref": "#/definitions/CustomAttributeTypedArgument"
        },
        "memberName": {
          "type": "string"
        },
        "isField": {
          "type": "boolean"
        }
      }
    },
    "Module": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "CustomAttributes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CustomAttributeData"
          }
        },
        "MDStreamVersion": {
          "type": "integer",
          "format": "int32"
        },
        "FullyQualifiedName": {
          "type": "string"
        },
        "ModuleVersionId": {
          "type": "string",
          "format": "guid"
        },
        "MetadataToken": {
          "type": "integer",
          "format": "int32"
        },
        "ScopeName": {
          "type": "string"
        },
        "Name": {
          "type": "string"
        },
        "Assembly": {
          "$ref": "#/definitions/Assembly"
        },
        "ModuleHandle": {
          "$ref": "#/definitions/ModuleHandle"
        }
      }
    },
    "Assembly": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "CodeBase": {
          "type": "string"
        },
        "EscapedCodeBase": {
          "type": "string"
        },
        "FullName": {
          "type": "string"
        },
        "EntryPoint": {
          "$ref": "#/definitions/MethodInfo"
        },
        "ExportedTypes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "DefinedTypes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "Evidence": {
          "type": "array",
          "items": {}
        },
        "PermissionSet": {
          "type": "array",
          "items": {}
        },
        "IsFullyTrusted": {
          "type": "boolean"
        },
        "SecurityRuleSet": {
          "$ref": "#/definitions/SecurityRuleSet"
        },
        "ManifestModule": {
          "$ref": "#/definitions/Module"
        },
        "CustomAttributes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CustomAttributeData"
          }
        },
        "ReflectionOnly": {
          "type": "boolean"
        },
        "Modules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Module"
          }
        },
        "Location": {
          "type": "string"
        },
        "ImageRuntimeVersion": {
          "type": "string"
        },
        "GlobalAssemblyCache": {
          "type": "boolean"
        },
        "HostContext": {
          "type": "integer",
          "format": "int64"
        },
        "IsDynamic": {
          "type": "boolean"
        }
      }
    },
    "SecurityRuleSet": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "None",
        "Level1",
        "Level2"
      ],
      "enum": [
        "none",
        "level1",
        "level2"
      ]
    },
    "ModuleHandle": {
      "type": "object",
      "properties": {
        "mdStreamVersion": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "SolarAltitudeDelegate": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object",
          "description": "Should return sin(solar altitude angle). i.e. -1 for 90 degrees far below horizon, 0 for horizon and 1 for vertical"
        }
      ]
    },
    "GetLatitudeDelegate": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "EnumMonth": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      "enum": [
        "january",
        "february",
        "march",
        "april",
        "may",
        "june",
        "july",
        "august",
        "september",
        "october",
        "november",
        "december"
      ]
    },
    "EnumMoonPhase": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Empty",
        "Grow1",
        "Grow2",
        "Grow3",
        "Full",
        "Shrink1",
        "Shrink2",
        "Shrink3"
      ],
      "enum": [
        "empty",
        "grow1",
        "grow2",
        "grow3",
        "full",
        "shrink1",
        "shrink2",
        "shrink3"
      ]
    },
    "CollisionTester": {
      "type": "object",
      "properties": {
        "collisionBoxList": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Cuboidd"
          }
        },
        "entityBox": {
          "$ref": "#/definitions/Cuboidd"
        },
        "tmpPos": {
          "$ref": "#/definitions/BlockPos"
        },
        "tmpPosDelta": {
          "$ref": "#/definitions/Vec3d"
        },
        "tmpPositionVec": {
          "$ref": "#/definitions/Vec3d"
        },
        "tempCuboid": {
          "$ref": "#/definitions/Cuboidd"
        }
      }
    },
    "Cuboidd": {
      "type": "object",
      "description": "Represents a three dimensional axis-aligned cuboid using two 3d coordinates. Used for collision and selection withes.",
      "properties": {
        "x1": {
          "type": "number",
          "format": "double"
        },
        "y1": {
          "type": "number",
          "format": "double"
        },
        "z1": {
          "type": "number",
          "format": "double"
        },
        "x2": {
          "type": "number",
          "format": "double"
        },
        "y2": {
          "type": "number",
          "format": "double"
        },
        "z2": {
          "type": "number",
          "format": "double"
        },
        "width": {
          "type": "number",
          "description": "MaxX-MinX",
          "format": "double"
        },
        "height": {
          "type": "number",
          "description": "MaxY-MinY",
          "format": "double"
        },
        "length": {
          "type": "number",
          "description": "MaxZ-MinZ",
          "format": "double"
        },
        "minX": {
          "type": "number",
          "format": "double"
        },
        "minY": {
          "type": "number",
          "format": "double"
        },
        "minZ": {
          "type": "number",
          "format": "double"
        },
        "maxX": {
          "type": "number",
          "format": "double"
        },
        "maxY": {
          "type": "number",
          "format": "double"
        },
        "maxZ": {
          "type": "number",
          "format": "double"
        },
        "start": {
          "$ref": "#/definitions/Vec3d"
        },
        "end": {
          "$ref": "#/definitions/Vec3d"
        }
      }
    },
    "Random": {
      "type": "object"
    },
    "CollectibleObject": {
      "allOf": [
        {
          "$ref": "#/definitions/RegistryObject"
        },
        {
          "type": "object",
          "description": "Contains all properties shared by Blocks and Items",
          "x-abstract": true,
          "properties": {
            "matterState": {
              "description": "Liquids are handled and rendered differently than solid blocks.",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumMatterState"
                }
              ]
            },
            "maxStackSize": {
              "type": "integer",
              "description": "Max amount of collectible that one default inventory slot can hold",
              "format": "int32"
            },
            "durability": {
              "type": "integer",
              "description": "How many uses does this collectible has when being used. Item disappears at durability 0",
              "format": "int32"
            },
            "dimensions": {
              "description": "Physical size of this collectible, 0.5 x 0.5 x 0.5 meters by default",
              "oneOf": [
                {
                  "$ref": "#/definitions/Size3f"
                }
              ]
            },
            "liquidSelectable": {
              "type": "boolean",
              "description": "When true, liquids become selectable to the player when being held in hands"
            },
            "attackPower": {
              "type": "number",
              "description": "How much damage this collectible deals when used as a weapon",
              "format": "float"
            },
            "attackRange": {
              "type": "number",
              "description": "Until how for away can you attack entities using this collectibe",
              "format": "float"
            },
            "damagedBy": {
              "type": "array",
              "description": "From which damage sources does the item takes durability damage",
              "items": {
                "$ref": "#/definitions/EnumItemDamageSource"
              }
            },
            "miningSpeed": {
              "type": "object",
              "description": "Modifies how fast the player can break a block when holding this item",
              "x-dictionaryKey": {
                "$ref": "#/definitions/EnumBlockMaterial"
              },
              "additionalProperties": {
                "type": "number",
                "format": "float"
              }
            },
            "toolTier": {
              "type": "integer",
              "description": "What tier this block can mine when held in hands",
              "format": "int32"
            },
            "heldSounds": {
              "$ref": "#/definitions/HeldSounds"
            },
            "creativeInventoryTabs": {
              "type": "array",
              "description": "List of creative tabs in which this collectible should appear in",
              "items": {
                "type": "string"
              }
            },
            "creativeInventoryStacks": {
              "type": "array",
              "description": "If you want to add itemstacks with custom attributes to the creative inventory, add them to this list",
              "items": {
                "$ref": "#/definitions/CreativeTabAndStackList"
              }
            },
            "renderAlphaTest": {
              "type": "number",
              "description": "Alpha test value for rendering in gui, fp hand, tp hand or on the ground",
              "format": "float"
            },
            "guiTransform": {
              "description": "Used for scaling, rotation or offseting the block when rendered in guis",
              "oneOf": [
                {
                  "$ref": "#/definitions/ModelTransform"
                }
              ]
            },
            "fpHandTransform": {
              "description": "Used for scaling, rotation or offseting the block when rendered in the first person mode hand",
              "oneOf": [
                {
                  "$ref": "#/definitions/ModelTransform"
                }
              ]
            },
            "tpHandTransform": {
              "description": "Used for scaling, rotation or offseting the block when rendered in the third person mode hand",
              "oneOf": [
                {
                  "$ref": "#/definitions/ModelTransform"
                }
              ]
            },
            "groundTransform": {
              "description": "Used for scaling, rotation or offseting the rendered as a dropped item on the ground",
              "oneOf": [
                {
                  "$ref": "#/definitions/ModelTransform"
                }
              ]
            },
            "attributes": {
              "description": "Custom Attributes that's always assiociated with this item",
              "oneOf": [
                {
                  "$ref": "#/definitions/JsonObject"
                }
              ]
            },
            "combustibleProps": {
              "description": "Information about the burnable states",
              "oneOf": [
                {
                  "$ref": "#/definitions/CombustibleProperties"
                }
              ]
            },
            "nutritionProps": {
              "description": "Information about the nutrition states",
              "oneOf": [
                {
                  "$ref": "#/definitions/FoodNutritionProperties"
                }
              ]
            },
            "transitionableProps": {
              "type": "array",
              "description": "Information about the transitionable states",
              "items": {
                "$ref": "#/definitions/TransitionableProperties"
              }
            },
            "grindingProps": {
              "description": "If set, the collectible can be ground into something else",
              "oneOf": [
                {
                  "$ref": "#/definitions/GrindingProperties"
                }
              ]
            },
            "crushingProps": {
              "description": "If set, the collectible can be crushed into something else",
              "oneOf": [
                {
                  "$ref": "#/definitions/CrushingProperties"
                }
              ]
            },
            "particleProperties": {
              "type": "array",
              "description": "Particles that should spawn in regular intervals from this block or item when held in hands",
              "items": {
                "$ref": "#/definitions/AdvancedParticleProperties"
              }
            },
            "topMiddlePos": {
              "description": "The origin point from which particles are being spawned",
              "oneOf": [
                {
                  "$ref": "#/definitions/Vec3f"
                }
              ]
            },
            "tool": {
              "description": "If set, this item will be classified as given tool",
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "$ref": "#/definitions/EnumTool"
                }
              ]
            },
            "storageFlags": {
              "description": "Determines in which kind of bags the item can be stored in",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumItemStorageFlags"
                }
              ]
            },
            "materialDensity": {
              "type": "integer",
              "description": "Determines on whether an object floats on liquids or not. Water has a density of 1000",
              "format": "int32"
            },
            "heldTpHitAnimation": {
              "type": "string",
              "description": "The animation to play in 3rd person mod when hitting with this collectible"
            },
            "heldRightTpIdleAnimation": {
              "type": "string",
              "description": "The animation to play in 3rd person mod when holding this collectible in the right hand"
            },
            "heldLeftTpIdleAnimation": {
              "type": "string",
              "description": "The animation to play in 3rd person mod when holding this collectible in the left hand"
            },
            "heldTpUseAnimation": {
              "type": "string",
              "description": "The animation to play in 3rd person mod when using this collectible"
            },
            "collectibleBehaviors": {
              "type": "array",
              "description": "Modifiers that can alter the behavior of the item or block, mostly for held interaction",
              "items": {
                "$ref": "#/definitions/CollectibleBehavior"
              }
            },
            "isMissing": {
              "type": "boolean",
              "description": "This value is set the the BlockId or ItemId-Remapper if it encounters a block/item in the savegame, \nbut no longer exists as a loaded block/item"
            },
            "miningTier": {
              "type": "integer",
              "format": "int32",
              "x-deprecated": true,
              "x-deprecatedMessage": "Use tool tier"
            }
          }
        }
      ]
    },
    "EnumMatterState": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Gas",
        "Liquid",
        "Solid",
        "Plasma",
        "BoseEinsteinCondensate"
      ],
      "enum": [
        "gas",
        "liquid",
        "solid",
        "plasma",
        "boseEinsteinCondensate"
      ]
    },
    "Size3f": {
      "type": "object",
      "description": "Represents a vector of 2 doubles. Go bug Tyron of you need more utility methods in this class.",
      "properties": {
        "width": {
          "type": "number",
          "format": "float"
        },
        "height": {
          "type": "number",
          "format": "float"
        },
        "length": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "EnumItemDamageSource": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "BlockBreaking",
        "Attacking",
        "Fire"
      ],
      "enum": [
        "blockBreaking",
        "attacking",
        "fire"
      ]
    },
    "EnumBlockMaterial": {
      "type": "string",
      "description": "Material of which a block my be made of\nCurrently only used for mining speed for tools",
      "x-enumNames": [
        "Air",
        "Soil",
        "Gravel",
        "Sand",
        "Wood",
        "Leaves",
        "Stone",
        "Ore",
        "Liquid",
        "Snow",
        "Ice",
        "Metal",
        "Mantle",
        "Plant",
        "Glass",
        "Ceramic",
        "Cloth",
        "Lava",
        "Brick",
        "Fire",
        "Meta",
        "Other"
      ],
      "enum": [
        "air",
        "soil",
        "gravel",
        "sand",
        "wood",
        "leaves",
        "stone",
        "ore",
        "liquid",
        "snow",
        "ice",
        "metal",
        "mantle",
        "plant",
        "glass",
        "ceramic",
        "cloth",
        "lava",
        "brick",
        "fire",
        "meta",
        "other"
      ]
    },
    "HeldSounds": {
      "type": "object",
      "properties": {
        "idle": {
          "type": "string"
        },
        "equip": {
          "type": "string"
        },
        "unequip": {
          "type": "string"
        },
        "attack": {
          "type": "string"
        }
      }
    },
    "CreativeTabAndStackList": {
      "type": "object",
      "properties": {
        "tabs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "stacks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JsonItemStack"
          }
        }
      }
    },
    "JsonItemStack": {
      "type": "object",
      "properties": {
        "type": {
          "description": "Block or Item?",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumItemClass"
            }
          ]
        },
        "code": {
          "type": "string",
          "description": "Code of the block or item"
        },
        "stackSize": {
          "type": "integer",
          "description": "Amount of items in this stacks",
          "format": "int32"
        },
        "attributes": {
          "description": "Tree Attributes that should be attached to the resulting itemstack",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonObject"
            }
          ]
        },
        "resolvedItemstack": {
          "description": "The resolved item after conversion.",
          "oneOf": [
            {
              "$ref": "#/definitions/ItemStack"
            }
          ]
        },
        "quantity": {
          "type": "integer",
          "description": "Alias of StackSize",
          "format": "int32"
        }
      }
    },
    "EnumItemClass": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Block",
        "Item"
      ],
      "enum": [
        "block",
        "item"
      ]
    },
    "ItemStack": {
      "type": "object",
      "properties": {
        "class": {
          "description": "Wether its a block Block or Item",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumItemClass"
            }
          ]
        },
        "id": {
          "type": "integer",
          "description": "The id of the block or item",
          "format": "int32"
        },
        "collectible": {
          "description": "The item/block base class this stack is holding",
          "oneOf": [
            {
              "$ref": "#/definitions/CollectibleObject"
            }
          ]
        },
        "item": {
          "description": "If this is a stack of items, this is the type of items it's holding, otherwise null",
          "oneOf": [
            {
              "$ref": "#/definitions/Item"
            }
          ]
        },
        "block": {
          "description": "If this is a stack of blocks, this is the type of block it's holding, otherwise null",
          "oneOf": [
            {
              "$ref": "#/definitions/Block"
            }
          ]
        },
        "stackSize": {
          "type": "integer",
          "description": "The amount of items/blocks in this stack",
          "format": "int32"
        },
        "attributes": {
          "type": "array",
          "description": "Attributes assigned to this particular itemstack which are saved and synchronized. ",
          "items": {}
        },
        "tempAttributes": {
          "type": "array",
          "description": "Temporary Attributes assigned to this particular itemstack, not synchronized, not saved! Modifiable.",
          "items": {}
        },
        "itemAttributes": {
          "description": "The Attributes assigned to the underlying block/item. Should not be modified, as it applies to globally.",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonObject"
            }
          ]
        }
      }
    },
    "Item": {
      "allOf": [
        {
          "$ref": "#/definitions/CollectibleObject"
        },
        {
          "type": "object",
          "description": "Represents an in game Item of Vintage Story",
          "properties": {
            "itemId": {
              "type": "integer",
              "description": "The unique number of the item, dynamically assigned by the game",
              "format": "int32"
            },
            "shape": {
              "description": "The items shape. Null for automatic shape based on the texture.",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeShape"
                }
              ]
            },
            "textures": {
              "type": "object",
              "description": "Default textures to be used for this block",
              "additionalProperties": {
                "$ref": "#/definitions/CompositeTexture"
              }
            },
            "id": {
              "type": "integer",
              "description": "The unique number of the item, dynamically assigned by the game",
              "format": "int32"
            },
            "itemClass": {
              "description": "The type of the collectible object",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumItemClass"
                }
              ]
            },
            "firstTexture": {
              "description": "Returns the first texture in Textures",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeTexture"
                }
              ]
            }
          }
        }
      ]
    },
    "CompositeShape": {
      "type": "object",
      "properties": {
        "base": {
          "type": "string"
        },
        "format": {
          "$ref": "#/definitions/EnumShapeFormat"
        },
        "insertBakedTextures": {
          "type": "boolean",
          "description": "Whether or not to insert baked in textures for mesh formats such as gltf into the texture atlas."
        },
        "rotateX": {
          "type": "number",
          "format": "float"
        },
        "rotateY": {
          "type": "number",
          "format": "float"
        },
        "rotateZ": {
          "type": "number",
          "format": "float"
        },
        "offsetX": {
          "type": "number",
          "format": "float"
        },
        "offsetY": {
          "type": "number",
          "format": "float"
        },
        "offsetZ": {
          "type": "number",
          "format": "float"
        },
        "scale": {
          "type": "number",
          "format": "float"
        },
        "alternates": {
          "type": "array",
          "description": "The block shape may consists of any amount of alternatives, one of which will be randomly chosen when the block is placed in the world.",
          "items": {
            "$ref": "#/definitions/CompositeShape"
          }
        },
        "bakedAlternates": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CompositeShape"
          }
        },
        "overlays": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CompositeShape"
          }
        },
        "voxelizeTexture": {
          "type": "boolean",
          "description": "If true, the shape is created from a voxelized version of the first defined texture"
        },
        "quantityElements": {
          "type": [
            "integer",
            "null"
          ],
          "description": "If non zero will only tesselate the first n elements of the shape",
          "format": "int32"
        },
        "selectiveElements": {
          "type": "array",
          "description": "If set will only tesselate elements with given name",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "EnumShapeFormat": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "VintageStory",
        "Obj",
        "GltfEmbedded"
      ],
      "enum": [
        "vintageStory",
        "obj",
        "gltfEmbedded"
      ]
    },
    "CompositeTexture": {
      "type": "object",
      "description": "A single block texture",
      "properties": {
        "base": {
          "type": "string",
          "description": "The basic texture for this composite texture"
        },
        "overlays": {
          "type": "array",
          "description": "The base texture may be overlayed with any quantity of textures. These are baked together during texture atlas creation",
          "items": {
            "type": "string"
          }
        },
        "alternates": {
          "type": "array",
          "description": "The texture may consists of any amount of alternatives, one of which will be randomly chosen when the block is placed in the world.",
          "items": {
            "$ref": "#/definitions/CompositeTexture"
          }
        },
        "baked": {
          "description": "BakedCompositeTexture is an expanded, atlas friendly version of CompositeTexture. Required during texture atlas generation.",
          "oneOf": [
            {
              "$ref": "#/definitions/BakedCompositeTexture"
            }
          ]
        },
        "rotation": {
          "type": "integer",
          "description": "Rotation of the texture may only be a multiple of 90",
          "format": "int32"
        },
        "alpha": {
          "type": "integer",
          "description": "Can be used to modify the opacity of the texture",
          "format": "int32"
        }
      }
    },
    "BakedCompositeTexture": {
      "type": "object",
      "description": "An expanded, atlas-friendly version of a CompositeTexture",
      "properties": {
        "textureSubId": {
          "type": "integer",
          "description": "Unique identifier for this texture",
          "format": "int32"
        },
        "bakedName": {
          "type": "string",
          "description": "The Base name and Overlay concatenated (if there was any defined)"
        },
        "textureFilenames": {
          "type": "array",
          "description": "The base name and overlays as array",
          "items": {
            "type": "string"
          }
        },
        "bakedVariants": {
          "type": "array",
          "description": "If non-null also contains BakedName",
          "items": {
            "$ref": "#/definitions/BakedCompositeTexture"
          }
        }
      }
    },
    "Block": {
      "allOf": [
        {
          "$ref": "#/definitions/CollectibleObject"
        },
        {
          "type": "object",
          "description": "Basic class for a placeable block",
          "properties": {
            "blockId": {
              "type": "integer",
              "description": "Unique number of the block. Same as Id. This number depends on the order in which the blocks are order. The numbering is however always ensured to remain the same on a per world basis.",
              "format": "int32"
            },
            "drawType": {
              "description": "If not set to JSON it will use an efficient hardcoded model",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumDrawType"
                }
              ]
            },
            "renderPass": {
              "description": "During which render pass this block should be rendered",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumChunkRenderPass"
                }
              ]
            },
            "ambientocclusion": {
              "type": "boolean",
              "description": "Currently not used"
            },
            "walkSpeedMultiplier": {
              "type": "number",
              "description": "Walk speed when standing or inside this block",
              "format": "float"
            },
            "dragMultiplier": {
              "type": "number",
              "description": "Drag multiplier applied to entities standing on it",
              "format": "float"
            },
            "partialSelection": {
              "type": "boolean",
              "description": "If true, players can target individual selection boxes of the block"
            },
            "sounds": {
              "description": "The sounds played for this block during step, break, build and walk. Use GetSounds() to query if not performance critical.",
              "oneOf": [
                {
                  "$ref": "#/definitions/BlockSounds"
                }
              ]
            },
            "vertexFlags": {
              "description": "Data thats passed on to the graphics card for every vertex of the blocks model",
              "oneOf": [
                {
                  "$ref": "#/definitions/VertexFlags"
                }
              ]
            },
            "frostable": {
              "type": "boolean",
              "description": "A bit uploaded to the shader to add a frost overlay below freezing temperature"
            },
            "lightHsv": {
              "type": "string",
              "description": "For light emitting blocks: hue, saturation and brightness value",
              "format": "byte"
            },
            "lightAbsorption": {
              "type": "integer",
              "description": "For light blocking blocks. Any value above 32 will completely block all light.",
              "format": "int32"
            },
            "lightTraversable": {
              "type": "array",
              "description": "0: West-East\n1: Up-Down\n2: North-South",
              "items": {
                "type": "boolean"
              }
            },
            "replaceable": {
              "type": "integer",
              "description": "A value usually between 0-9999 that indicates which blocks may be replaced with others.\n- Any block with replaceable value above 5000 will be washed away by water\n- Any block with replaceable value above 6000 will replaced when the player tries to place a block\nExamples:\n0 = Bedrock\n6000 = Tallgrass\n9000 = Lava\n9500 = Water\n9999 = Air",
              "format": "int32"
            },
            "fertility": {
              "type": "integer",
              "description": "0 = nothing can grow, 10 = some tallgrass and small trees can be grow on it, 100 = all grass and trees can grow on it",
              "format": "int32"
            },
            "requiredMiningTier": {
              "type": "integer",
              "description": "The mining tier required to break this block",
              "format": "int32"
            },
            "resistance": {
              "type": "number",
              "description": "How long it takes to break this block in seconds. Use GetResistance() to query if not performance critical.",
              "format": "float"
            },
            "blockMaterial": {
              "description": "A way to categorize blocks. Used for getting the mining speed for each tool type, amongst other things. Use GetBlockMaterial() to query if not performance critical.",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumBlockMaterial"
                }
              ]
            },
            "randomizeAxes": {
              "description": "Random texture selection - whether or not to use the Y axis during randomization (for multiblock plants)",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumRandomizeAxes"
                }
              ]
            },
            "randomDrawOffset": {
              "type": "integer",
              "description": "If true then the block will be randomly offseted by 1/3 of a block when placed",
              "format": "int32"
            },
            "randomizeRotations": {
              "type": "boolean"
            },
            "randomSizeAdjust": {
              "type": "number",
              "format": "float"
            },
            "alternatingVOffset": {
              "type": "boolean",
              "description": "If true, the block will render with a UV offset enabling it to use the \"other half\" of a 64 x 64 texture on each alternate block position  (e.g. Redwood trunk)"
            },
            "alternatingVOffsetFaces": {
              "type": "integer",
              "description": "Bit flags for the direction in which the alternatingVOffset is to be applied e.g. 0x30 to apply alternatingVOffset as the y position moves up and down",
              "format": "int32"
            },
            "shapeInventory": {
              "description": "The block shape to be used when displayed in the inventory gui, held in hand or dropped on the ground",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeShape"
                }
              ]
            },
            "shape": {
              "description": "The default json block shape to be used when drawtype==JSON",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeShape"
                }
              ]
            },
            "lod0Shape": {
              "$ref": "#/definitions/CompositeShape"
            },
            "lod2Shape": {
              "$ref": "#/definitions/CompositeShape"
            },
            "lod0Mesh": {
              "$ref": "#/definitions/MeshData"
            },
            "lod2Mesh": {
              "$ref": "#/definitions/MeshData"
            },
            "doNotRenderAtLod2": {
              "type": "boolean"
            },
            "textures": {
              "type": "object",
              "description": "Default textures to be used for this block\n(may be null, on servers prior to reading blockType, on clients prior to receipt of server assets)",
              "additionalProperties": {
                "$ref": "#/definitions/CompositeTexture"
              }
            },
            "fastTextureVariants": {
              "type": "array",
              "description": "Fast array of texture variants, for use by cube (or similar) tesselators if the block has alternate shapes\nThe outer array is indexed based on the 6 BlockFacing.Index numerals; the inner array is the variants",
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/BakedCompositeTexture"
                }
              }
            },
            "texturesInventory": {
              "type": "object",
              "description": "Textures to be used for this block in the inventory gui, held in hand or dropped on the ground\n(may be null, on servers prior to reading blockType, on clients prior to receipt of server assets)",
              "additionalProperties": {
                "$ref": "#/definitions/CompositeTexture"
              }
            },
            "sideOpaque": {
              "type": "array",
              "description": "Defines which of the 6 block sides are completely opaque. Used to determine which block faces can be culled during tesselation.",
              "items": {
                "type": "boolean"
              }
            },
            "sideSolid": {
              "type": "array",
              "description": "Defines which of the 6 block side are solid. Used to determine if attachable blocks can be attached to this block. Also used to determine if snow can rest on top of this block.",
              "items": {
                "type": "boolean"
              }
            },
            "sideAo": {
              "type": "array",
              "description": "Defines which of the 6 block side should be shaded with ambient occlusion",
              "items": {
                "type": "boolean"
              }
            },
            "emitSideAo": {
              "type": "integer",
              "description": "Defines which of the 6 block neighbours should receive AO if this block is in front of them",
              "format": "byte"
            },
            "allowSpawnCreatureGroups": {
              "type": "array",
              "description": "Defines what creature groups may spawn on this block",
              "items": {
                "type": "string"
              }
            },
            "faceCullMode": {
              "description": "Determines which sides of the blocks should be rendered",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumFaceCullMode"
                }
              ]
            },
            "climateColorMap": {
              "type": "string",
              "description": "The color map for climate color mapping. Leave null for no coloring by climate"
            },
            "climateColorMapResolved": {
              "$ref": "#/definitions/ColorMap"
            },
            "seasonColorMap": {
              "type": "string",
              "description": "The color map for season color mapping. Leave null for no coloring by season"
            },
            "seasonColorMapResolved": {
              "$ref": "#/definitions/ColorMap"
            },
            "shapeUsesColormap": {
              "type": "boolean",
              "description": "Internal value that's set during if the block shape has any tint indexes for use in chunk tesselation and stuff O_O"
            },
            "loadColorMapAnyway": {
              "type": "boolean"
            },
            "collisionBoxes": {
              "type": "array",
              "description": "Defines the area with which the player character collides with.",
              "items": {
                "$ref": "#/definitions/Cuboidf"
              }
            },
            "selectionBoxes": {
              "type": "array",
              "description": "Defines the area which the players mouse pointer collides with for selection.",
              "items": {
                "$ref": "#/definitions/Cuboidf"
              }
            },
            "particleCollisionBoxes": {
              "type": "array",
              "description": "Defines the area with which particles collide with (if null, will be the same as CollisionBoxes).",
              "items": {
                "$ref": "#/definitions/Cuboidf"
              }
            },
            "climbable": {
              "type": "boolean",
              "description": "Used for ladders. If true, walking against this blocks collisionbox will make the player climb"
            },
            "rainPermeable": {
              "type": "boolean",
              "description": "Will be used for not rendering rain below this block"
            },
            "liquidLevel": {
              "type": "integer",
              "description": "Value between 0..7 for Liquids to determine the height of the liquid",
              "format": "int32"
            },
            "liquidCode": {
              "type": "string",
              "description": "If this block is or contains a liquid, this should be the code (or \"identifier\") of the liquid"
            },
            "hasAlternates": {
              "type": "boolean",
              "description": "A flag set during texture block shape tesselation"
            },
            "blockBehaviors": {
              "type": "array",
              "description": "Modifiers that can alter the behavior of a block, particularly when being placed or removed",
              "items": {
                "$ref": "#/definitions/BlockBehavior"
              }
            },
            "blockEntityBehaviors": {
              "type": "array",
              "description": "Modifiers that can alter the behavior of a block entity",
              "items": {
                "$ref": "#/definitions/BlockEntityBehaviorType"
              }
            },
            "drops": {
              "type": "array",
              "description": "The items that should drop from breaking this block",
              "items": {
                "$ref": "#/definitions/BlockDropItemStack"
              }
            },
            "splitDropStacks": {
              "type": "boolean",
              "description": "If true, a blocks drops will be split into stacks of stacksize 1 for more game juice. This field is only used in OnBlockBroken() and OnBlockExploded()"
            },
            "cropProps": {
              "description": "Information about the blocks as a crop ",
              "oneOf": [
                {
                  "$ref": "#/definitions/BlockCropProperties"
                }
              ]
            },
            "entityClass": {
              "type": "string",
              "description": "If this block has a block entity attached to it, this will store it's code "
            },
            "canStep": {
              "type": "boolean"
            },
            "allowStepWhenStuck": {
              "type": "boolean"
            },
            "decorBehaviorFlags": {
              "type": "integer",
              "description": "To allow Decor Behavior settings to be accessed through the Block API.  See DecorFlags class for interpretation.",
              "format": "byte"
            },
            "decorThickness": {
              "type": "number",
              "description": "Used to adjust selection box of parent block",
              "format": "float"
            },
            "interactionHelpYOffset": {
              "type": "number",
              "format": "float"
            },
            "textureSubIdForBlockColor": {
              "type": "integer",
              "format": "int32"
            },
            "notSnowCovered": {
              "$ref": "#/definitions/Block"
            },
            "snowCovered1": {
              "$ref": "#/definitions/Block"
            },
            "snowCovered2": {
              "$ref": "#/definitions/Block"
            },
            "snowCovered3": {
              "$ref": "#/definitions/Block"
            },
            "snowLevel": {
              "type": "number",
              "format": "float"
            },
            "waveFlagMinY": {
              "type": "number",
              "format": "float"
            },
            "id": {
              "type": "integer",
              "description": "Returns the block id",
              "format": "int32"
            },
            "itemClass": {
              "description": "Returns EnumItemClass.Block",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumItemClass"
                }
              ]
            },
            "firstTextureInventory": {
              "description": "Returns the first textures in the TexturesInventory dictionary",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeTexture"
                }
              ]
            },
            "pushVector": {
              "description": "Entity pushing while an entity is inside this block. Read from attributes because i'm lazy.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Vec3d"
                }
              ]
            },
            "allSidesOpaque": {
              "type": "boolean",
              "description": "Sets the whole SideOpaque array to true "
            },
            "climateColorMapForMap": {
              "type": "string"
            },
            "seasonColorMapForMap": {
              "type": "string"
            }
          }
        }
      ]
    },
    "EnumDrawType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "BlockLayer_1",
        "BlockLayer_2",
        "BlockLayer_3",
        "BlockLayer_4",
        "BlockLayer_5",
        "BlockLayer_6",
        "BlockLayer_7",
        "JSON",
        "Empty",
        "Cube",
        "Cross",
        "Transparent",
        "Liquid",
        "TopSoil",
        "CrossAndSnowlayer",
        "JSONAndWater",
        "JSONAndSnowLayer",
        "CrossAndSnowlayer_2",
        "CrossAndSnowlayer_3",
        "CrossAndSnowlayer_4",
        "SurfaceLayer"
      ],
      "enum": [
        "blockLayer_1",
        "blockLayer_2",
        "blockLayer_3",
        "blockLayer_4",
        "blockLayer_5",
        "blockLayer_6",
        "blockLayer_7",
        "json",
        "empty",
        "cube",
        "cross",
        "transparent",
        "liquid",
        "topSoil",
        "crossAndSnowlayer",
        "jsonAndWater",
        "jsonAndSnowLayer",
        "crossAndSnowlayer_2",
        "crossAndSnowlayer_3",
        "crossAndSnowlayer_4",
        "surfaceLayer"
      ]
    },
    "EnumChunkRenderPass": {
      "type": "string",
      "description": "The various render passes available for rendering blocks",
      "x-enumNames": [
        "Opaque",
        "OpaqueNoCull",
        "BlendNoCull",
        "Transparent",
        "Liquid",
        "TopSoil",
        "Meta"
      ],
      "enum": [
        "opaque",
        "opaqueNoCull",
        "blendNoCull",
        "transparent",
        "liquid",
        "topSoil",
        "meta"
      ]
    },
    "BlockSounds": {
      "type": "object",
      "properties": {
        "ambient": {
          "type": "string"
        },
        "ambientBlockCount": {
          "type": "number",
          "format": "float"
        },
        "walk": {
          "type": "string"
        },
        "inside": {
          "type": "string"
        },
        "break": {
          "type": "string"
        },
        "place": {
          "type": "string"
        },
        "hit": {
          "type": "string"
        },
        "byTool": {
          "type": "object",
          "description": "Gets the sound that occurs when a specific tool hits a block.",
          "x-dictionaryKey": {
            "$ref": "#/definitions/EnumTool"
          },
          "additionalProperties": {
            "$ref": "#/definitions/BlockSounds"
          }
        }
      }
    },
    "EnumTool": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Knife",
        "Pickaxe",
        "Axe",
        "Sword",
        "Shovel",
        "Hammer",
        "Spear",
        "Bow",
        "Shears",
        "Sickle",
        "Hoe",
        "Saw",
        "Chisel",
        "Scythe"
      ],
      "enum": [
        "knife",
        "pickaxe",
        "axe",
        "sword",
        "shovel",
        "hammer",
        "spear",
        "bow",
        "shears",
        "sickle",
        "hoe",
        "saw",
        "chisel",
        "scythe"
      ]
    },
    "VertexFlags": {
      "type": "object",
      "description": "Special class to handle the vertex flagging in a very nicely compressed space.",
      "properties": {
        "all": {
          "type": "integer",
          "format": "int32"
        },
        "allWithoutWaveFlags": {
          "type": "integer",
          "format": "int32"
        },
        "glowLevel": {
          "type": "integer",
          "format": "byte"
        },
        "zOffset": {
          "type": "integer",
          "format": "byte"
        },
        "grassWindWave": {
          "type": "boolean"
        },
        "waterWave": {
          "type": "boolean"
        },
        "reflective": {
          "type": "boolean"
        },
        "weakWave": {
          "type": "boolean"
        },
        "normal": {
          "type": "integer",
          "format": "int32"
        },
        "leavesWindWave": {
          "type": "boolean"
        },
        "windSway": {
          "type": "boolean"
        },
        "foliageWaveSpecial": {
          "type": "integer",
          "description": "0 = default\n1 = On weak wave, also have only low frequency jiggle\n2 = unused\n3 = Solid fruit and Stalk, rotate with origin\n4 = Fruit underleaves"
        },
        "lod0Fade": {
          "type": "boolean"
        }
      }
    },
    "EnumRandomizeAxes": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "XYZ",
        "XZ"
      ],
      "enum": [
        "xyz",
        "xz"
      ]
    },
    "MeshData": {
      "type": "object",
      "description": "A data structure that can be used to upload mesh information onto the graphics card\nPlease note, all arrays are used as a buffer. They do not tightly fit the data but are always sized as a multiple of 2 from the initial size.",
      "properties": {
        "xyz": {
          "type": "array",
          "description": "The x/y/z coordinates buffer. This should hold VerticesCount*3 values.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "flags": {
          "type": "array",
          "description": "The render flags buffer. This should hold VerticesCount*1 values.",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "normals": {
          "type": "array",
          "description": "The normals buffer. This should hold VerticesCount*1 values. Currently unused by the engine.\nGL_INT_2_10_10_10_REV Format\nx: bits 0-9    (10 bit signed int)\ny: bits 10-19  (10 bit signed int)\nz: bits 20-29  (10 bit signed int) \nw: bits 30-31",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "uv": {
          "type": "array",
          "description": "The uv buffer for texture coordinates. This should hold VerticesCount*2 values.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "rgba": {
          "type": "string",
          "description": "The vertex color buffer. This should hold VerticesCount*4 values.",
          "format": "byte"
        },
        "indices": {
          "type": "array",
          "description": "The indices buffer. This should hold IndicesCount values.",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "customFloats": {
          "description": "Custom floats buffer. Can be used to upload arbitrary amounts of float values onto the graphics card",
          "oneOf": [
            {
              "$ref": "#/definitions/CustomMeshDataPartFloat"
            }
          ]
        },
        "customInts": {
          "description": "Custom ints buffer. Can be used to upload arbitrary amounts of int values onto the graphics card",
          "oneOf": [
            {
              "$ref": "#/definitions/CustomMeshDataPartInt"
            }
          ]
        },
        "customShorts": {
          "description": "Custom shorts buffer. Can be used to upload arbitrary amounts of short values onto the graphics card",
          "oneOf": [
            {
              "$ref": "#/definitions/CustomMeshDataPartShort"
            }
          ]
        },
        "customBytes": {
          "description": "Custom bytes buffer. Can be used to upload arbitrary amounts of byte values onto the graphics card",
          "oneOf": [
            {
              "$ref": "#/definitions/CustomMeshDataPartByte"
            }
          ]
        },
        "xyzInstanced": {
          "type": "boolean",
          "description": "When using instanced rendering, set this flag to have the xyz values instanced."
        },
        "uvInstanced": {
          "type": "boolean",
          "description": "When using instanced rendering, set this flag to have the uv values instanced."
        },
        "rgbaInstanced": {
          "type": "boolean",
          "description": "When using instanced rendering, set this flag to have the rgba values instanced."
        },
        "rgba2Instanced": {
          "type": "boolean",
          "description": "When using instanced rendering, set this flag to have the rgba2 values instanced."
        },
        "indicesInstanced": {
          "type": "boolean",
          "description": "When using instanced rendering, set this flag to have the indices instanced."
        },
        "flagsInstanced": {
          "type": "boolean",
          "description": "When using instanced rendering, set this flag to have the flags instanced."
        },
        "xyzStatic": {
          "type": "boolean",
          "description": "xyz vbo usage hints for the graphics card. Recommended to be set to false when this section of data changes often."
        },
        "uvStatic": {
          "type": "boolean",
          "description": "uv vbo usage hints for the graphics card. Recommended to be set to false when this section of data changes often."
        },
        "rgbaStatic": {
          "type": "boolean",
          "description": "rgab vbo usage hints for the graphics card. Recommended to be set to false when this section of data changes often."
        },
        "rgba2Static": {
          "type": "boolean",
          "description": "rgba2 vbo usage hints for the graphics card. Recommended to be set to false when this section of data changes often."
        },
        "indicesStatic": {
          "type": "boolean",
          "description": "indices vbo usage hints for the graphics card. Recommended to be set to false when this section of data changes often."
        },
        "flagsStatic": {
          "type": "boolean",
          "description": "flags vbo usage hints for the graphics card. Recommended to be set to false when this section of data changes often."
        },
        "xyzOffset": {
          "type": "integer",
          "description": "For offseting the data in the VBO. This field is used when updating a mesh.",
          "format": "int32"
        },
        "uvOffset": {
          "type": "integer",
          "description": "For offseting the data in the VBO. This field is used when updating a mesh.",
          "format": "int32"
        },
        "rgbaOffset": {
          "type": "integer",
          "description": "For offseting the data in the VBO. This field is used when updating a mesh.",
          "format": "int32"
        },
        "rgba2Offset": {
          "type": "integer",
          "description": "For offseting the data in the VBO. This field is used when updating a mesh.",
          "format": "int32"
        },
        "flagsOffset": {
          "type": "integer",
          "description": "For offseting the data in the VBO. This field is used when updating a mesh.",
          "format": "int32"
        },
        "normalsOffset": {
          "type": "integer",
          "description": "For offseting the data in the VBO. This field is used when updating a mesh.",
          "format": "int32"
        },
        "indicesOffset": {
          "type": "integer",
          "description": "For offseting the data in the VBO. This field is used when updating a mesh.",
          "format": "int32"
        },
        "mode": {
          "description": "The meshes draw mode",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumDrawMode"
            }
          ]
        },
        "normalsCount": {
          "type": "integer",
          "description": "Amount of currently assigned normals",
          "format": "int32"
        },
        "verticesCount": {
          "type": "integer",
          "description": "Amount of currently assigned vertices",
          "format": "int32"
        },
        "indicesCount": {
          "type": "integer",
          "description": "Amount of currently assigned indices",
          "format": "int32"
        },
        "verticesMax": {
          "type": "integer",
          "description": "Vertex buffer size",
          "format": "int32"
        },
        "indicesMax": {
          "type": "integer",
          "description": "Index buffer size",
          "format": "int32"
        },
        "xyzFaces": {
          "type": "string",
          "description": "BlockShapeTesselator xyz faces. Required by TerrainChunkTesselator to determine vertex lightness. Should hold VerticesCount / 4 values. Set to 0 for no face, set to 1..8 for faces 0..7",
          "format": "byte"
        },
        "xyzFacesCount": {
          "type": "integer",
          "description": "Amount of assigned xyz face values",
          "format": "int32"
        },
        "indicesPerFace": {
          "type": "integer",
          "format": "int32"
        },
        "verticesPerFace": {
          "type": "integer",
          "format": "int32"
        },
        "climateColorMapIds": {
          "type": "string",
          "description": "BlockShapeTesselator climate colormap ids. Required by TerrainChunkTesselator to determine whether to color a vertex by a color map or not. Should hold VerticesCount / 4 values. Set to 0 for no color mapping, set 1..n for color map 0..n-1",
          "format": "byte"
        },
        "seasonColorMapIds": {
          "type": "string",
          "description": "BlockShapeTesselator season colormap ids. Required by TerrainChunkTesselator to determine whether to color a vertex by a color map or not. Should hold VerticesCount / 4 values. Set to 0 for no color mapping, set 1..n for color map 0..n-1",
          "format": "byte"
        },
        "renderPassesAndExtraBits": {
          "type": "array",
          "description": "BlockShapeTesselator renderpass. Required by TerrainChunkTesselator to determine in which mesh data pool each quad should land in. Should hold VerticesCount / 4 values.\nLower 10 bits = render pass\nUpper 6 bits = extra bits for tesselators\n   Bit 10: DisableRandomDrawOffset",
          "items": {
            "type": "integer"
          }
        },
        "colorMapIdsCount": {
          "type": "integer",
          "description": "Amount of assigned tint values",
          "format": "int32"
        },
        "renderPassCount": {
          "type": "integer",
          "description": "Amount of assigned render pass values",
          "format": "int32"
        },
        "renderPasses": {
          "type": "array",
          "x-deprecated": true,
          "x-deprecatedMessage": "Use RenderPassesAndExtraBits instead",
          "items": {
            "type": "integer"
          }
        },
        "xyzCount": {
          "type": "integer",
          "description": "returns VerticesCount * 3",
          "format": "int32"
        },
        "rgbaCount": {
          "type": "integer",
          "description": "returns VerticesCount * 4",
          "format": "int32"
        },
        "rgba2Count": {
          "type": "integer",
          "description": "returns VerticesCount * 4",
          "format": "int32"
        },
        "flagsCount": {
          "type": "integer",
          "description": "returns VerticesCount",
          "format": "int32"
        },
        "uvCount": {
          "type": "integer",
          "description": "returns VerticesCount * 2",
          "format": "int32"
        }
      }
    },
    "CustomMeshDataPartFloat": {
      "allOf": [
        {
          "$ref": "#/definitions/CustomMeshDataPartOfSingle"
        },
        {
          "type": "object",
          "description": "Holds arbitrary float data for meshes to be used in the shader"
        }
      ]
    },
    "CustomMeshDataPartOfSingle": {
      "type": "object",
      "description": "Holds arbitrary mesh data for meshes to be used in a shader",
      "x-abstract": true,
      "properties": {
        "values": {
          "type": "array",
          "description": "The arbitrary data to be uploaded to the graphics card",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "count": {
          "type": "integer",
          "description": "Amout of values currently added",
          "format": "int32"
        },
        "interleaveSizes": {
          "type": "array",
          "description": "Amount of variable components for variable (i.e. 2, 3 for a vec2 and a vec3), valid values are 1, 2, 3 and 4 (limited by glVertexAttribPointer)",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "interleaveStride": {
          "type": "integer",
          "description": "Stride - Size in bytes of all values for one vertex",
          "format": "int32"
        },
        "interleaveOffsets": {
          "type": "array",
          "description": "Offset in bytes for each variable ",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "instanced": {
          "type": "boolean",
          "description": "For instanced rendering"
        },
        "staticDraw": {
          "type": "boolean",
          "description": "Set to false if you intend to update the buffer very often (i.e. every frame)"
        },
        "baseOffset": {
          "type": "integer",
          "description": "Used as offset when doing a partial update on an existing buffer",
          "format": "int32"
        },
        "bufferSize": {
          "type": "integer",
          "description": "Size of the Values array",
          "format": "int32"
        },
        "allocationSize": {
          "type": "integer",
          "description": "Size of the array that should be allocated on the graphics card.",
          "format": "int32"
        }
      }
    },
    "CustomMeshDataPartInt": {
      "allOf": [
        {
          "$ref": "#/definitions/CustomMeshDataPartOfInteger"
        },
        {
          "type": "object",
          "description": "Holds arbitrary int data for meshes to be used in the shader",
          "properties": {
            "conversion": {
              "$ref": "#/definitions/DataConversion"
            }
          }
        }
      ]
    },
    "DataConversion": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Float",
        "NormalizedFloat",
        "Integer"
      ],
      "enum": [
        "float",
        "normalizedFloat",
        "integer"
      ]
    },
    "CustomMeshDataPartOfInteger": {
      "type": "object",
      "description": "Holds arbitrary mesh data for meshes to be used in a shader",
      "x-abstract": true,
      "properties": {
        "values": {
          "type": "array",
          "description": "The arbitrary data to be uploaded to the graphics card",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "count": {
          "type": "integer",
          "description": "Amout of values currently added",
          "format": "int32"
        },
        "interleaveSizes": {
          "type": "array",
          "description": "Amount of variable components for variable (i.e. 2, 3 for a vec2 and a vec3), valid values are 1, 2, 3 and 4 (limited by glVertexAttribPointer)",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "interleaveStride": {
          "type": "integer",
          "description": "Stride - Size in bytes of all values for one vertex",
          "format": "int32"
        },
        "interleaveOffsets": {
          "type": "array",
          "description": "Offset in bytes for each variable ",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "instanced": {
          "type": "boolean",
          "description": "For instanced rendering"
        },
        "staticDraw": {
          "type": "boolean",
          "description": "Set to false if you intend to update the buffer very often (i.e. every frame)"
        },
        "baseOffset": {
          "type": "integer",
          "description": "Used as offset when doing a partial update on an existing buffer",
          "format": "int32"
        },
        "bufferSize": {
          "type": "integer",
          "description": "Size of the Values array",
          "format": "int32"
        },
        "allocationSize": {
          "type": "integer",
          "description": "Size of the array that should be allocated on the graphics card.",
          "format": "int32"
        }
      }
    },
    "CustomMeshDataPartShort": {
      "allOf": [
        {
          "$ref": "#/definitions/CustomMeshDataPartOfShort"
        },
        {
          "type": "object",
          "description": "Holds arbitrary short data for meshes to be used in the shader",
          "properties": {
            "conversion": {
              "$ref": "#/definitions/DataConversion"
            }
          }
        }
      ]
    },
    "CustomMeshDataPartOfShort": {
      "type": "object",
      "description": "Holds arbitrary mesh data for meshes to be used in a shader",
      "x-abstract": true,
      "properties": {
        "values": {
          "type": "array",
          "description": "The arbitrary data to be uploaded to the graphics card",
          "items": {
            "type": "integer"
          }
        },
        "count": {
          "type": "integer",
          "description": "Amout of values currently added",
          "format": "int32"
        },
        "interleaveSizes": {
          "type": "array",
          "description": "Amount of variable components for variable (i.e. 2, 3 for a vec2 and a vec3), valid values are 1, 2, 3 and 4 (limited by glVertexAttribPointer)",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "interleaveStride": {
          "type": "integer",
          "description": "Stride - Size in bytes of all values for one vertex",
          "format": "int32"
        },
        "interleaveOffsets": {
          "type": "array",
          "description": "Offset in bytes for each variable ",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "instanced": {
          "type": "boolean",
          "description": "For instanced rendering"
        },
        "staticDraw": {
          "type": "boolean",
          "description": "Set to false if you intend to update the buffer very often (i.e. every frame)"
        },
        "baseOffset": {
          "type": "integer",
          "description": "Used as offset when doing a partial update on an existing buffer",
          "format": "int32"
        },
        "bufferSize": {
          "type": "integer",
          "description": "Size of the Values array",
          "format": "int32"
        },
        "allocationSize": {
          "type": "integer",
          "description": "Size of the array that should be allocated on the graphics card.",
          "format": "int32"
        }
      }
    },
    "CustomMeshDataPartByte": {
      "allOf": [
        {
          "$ref": "#/definitions/CustomMeshDataPartOfByte"
        },
        {
          "type": "object",
          "description": "Holds arbitrary byte data for meshes to be used in the shader",
          "properties": {
            "conversion": {
              "$ref": "#/definitions/DataConversion"
            }
          }
        }
      ]
    },
    "CustomMeshDataPartOfByte": {
      "type": "object",
      "description": "Holds arbitrary mesh data for meshes to be used in a shader",
      "x-abstract": true,
      "properties": {
        "values": {
          "type": "string",
          "description": "The arbitrary data to be uploaded to the graphics card",
          "format": "byte"
        },
        "count": {
          "type": "integer",
          "description": "Amout of values currently added",
          "format": "int32"
        },
        "interleaveSizes": {
          "type": "array",
          "description": "Amount of variable components for variable (i.e. 2, 3 for a vec2 and a vec3), valid values are 1, 2, 3 and 4 (limited by glVertexAttribPointer)",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "interleaveStride": {
          "type": "integer",
          "description": "Stride - Size in bytes of all values for one vertex",
          "format": "int32"
        },
        "interleaveOffsets": {
          "type": "array",
          "description": "Offset in bytes for each variable ",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "instanced": {
          "type": "boolean",
          "description": "For instanced rendering"
        },
        "staticDraw": {
          "type": "boolean",
          "description": "Set to false if you intend to update the buffer very often (i.e. every frame)"
        },
        "baseOffset": {
          "type": "integer",
          "description": "Used as offset when doing a partial update on an existing buffer",
          "format": "int32"
        },
        "bufferSize": {
          "type": "integer",
          "description": "Size of the Values array",
          "format": "int32"
        },
        "allocationSize": {
          "type": "integer",
          "description": "Size of the array that should be allocated on the graphics card.",
          "format": "int32"
        }
      }
    },
    "EnumDrawMode": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Triangles",
        "Lines",
        "LineStrip"
      ],
      "enum": [
        "triangles",
        "lines",
        "lineStrip"
      ]
    },
    "EnumFaceCullMode": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Default",
        "NeverCull",
        "Merge",
        "Collapse",
        "MergeMaterial",
        "CollapseMaterial",
        "Liquid",
        "Callback",
        "MergeSnowLayer",
        "FlushExceptTop",
        "Stairs"
      ],
      "enum": [
        "default",
        "neverCull",
        "merge",
        "collapse",
        "mergeMaterial",
        "collapseMaterial",
        "liquid",
        "callback",
        "mergeSnowLayer",
        "flushExceptTop",
        "stairs"
      ]
    },
    "ColorMap": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string"
        },
        "texture": {
          "$ref": "#/definitions/CompositeTexture"
        },
        "padding": {
          "type": "integer",
          "format": "int32"
        },
        "loadIntoBlockTextureAtlas": {
          "type": "boolean"
        },
        "extraFlags": {
          "type": "integer",
          "format": "int32"
        },
        "pixels": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "outerSize": {
          "$ref": "#/definitions/Size2i"
        },
        "blockAtlasTextureSubId": {
          "type": "integer",
          "format": "int32"
        },
        "rectIndex": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Size2i": {
      "type": "object",
      "description": "Represents a vector of 2 doubles. Go bug Tyron of you need more utility methods in this class.",
      "properties": {
        "width": {
          "type": "integer",
          "format": "int32"
        },
        "height": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Cuboidf": {
      "type": "object",
      "description": "Represents a three dimensional axis-aligned cuboid using two 3d coordinates. Used for collision and selection boxes.",
      "properties": {
        "x1": {
          "type": "number",
          "format": "float"
        },
        "y1": {
          "type": "number",
          "format": "float"
        },
        "z1": {
          "type": "number",
          "format": "float"
        },
        "x2": {
          "type": "number",
          "format": "float"
        },
        "y2": {
          "type": "number",
          "format": "float"
        },
        "z2": {
          "type": "number",
          "format": "float"
        },
        "xSize": {
          "type": "number",
          "description": "This is equivalent to width so long as X2 &gt; X1, but could in theory be a negative number if the box has its corners the wrong way around",
          "format": "float"
        },
        "ySize": {
          "type": "number",
          "description": "This is equivalent to height so long as Y2 &gt; Y1, but could in theory be a negative number if the box has its corners the wrong way around",
          "format": "float"
        },
        "zSize": {
          "type": "number",
          "description": "This is equivalent to length so long as Z2 &gt; Z1, but could in theory be a negative number if the box has its corners the wrong way around",
          "format": "float"
        },
        "width": {
          "type": "number",
          "format": "float"
        },
        "height": {
          "type": "number",
          "format": "float"
        },
        "length": {
          "type": "number",
          "format": "float"
        },
        "minX": {
          "type": "number",
          "format": "float"
        },
        "minY": {
          "type": "number",
          "format": "float"
        },
        "minZ": {
          "type": "number",
          "format": "float"
        },
        "maxX": {
          "type": "number",
          "format": "float"
        },
        "maxY": {
          "type": "number",
          "format": "float"
        },
        "maxZ": {
          "type": "number",
          "format": "float"
        },
        "midX": {
          "type": "number",
          "format": "float"
        },
        "midY": {
          "type": "number",
          "format": "float"
        },
        "midZ": {
          "type": "number",
          "format": "float"
        },
        "empty": {
          "type": "boolean",
          "description": "True when all values are 0"
        },
        "start": {
          "$ref": "#/definitions/Vec3f"
        },
        "end": {
          "$ref": "#/definitions/Vec3f"
        }
      }
    },
    "BlockBehavior": {
      "allOf": [
        {
          "$ref": "#/definitions/CollectibleBehavior"
        },
        {
          "type": "object",
          "x-abstract": true,
          "properties": {
            "block": {
              "description": "The block for this behavior instance.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Block"
                }
              ]
            }
          }
        }
      ]
    },
    "CollectibleBehavior": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "collObj": {
          "description": "The collectible object (item or block) for this behavior instance.",
          "oneOf": [
            {
              "$ref": "#/definitions/CollectibleObject"
            }
          ]
        },
        "propertiesAtString": {
          "type": "string",
          "description": "The properties of this block behavior."
        },
        "clientSideOptional": {
          "type": "boolean",
          "description": "If true, this behavior is not required on the client. This is here because copygirl doesn't stop asking for it. Probably breaks things. If it breaks things, complain to copygirl please :p"
        }
      }
    },
    "BlockEntityBehaviorType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "properties": {
          "$ref": "#/definitions/JsonObject"
        }
      }
    },
    "BlockDropItemStack": {
      "type": "object",
      "description": "Represents an itemstack that is dropped by chance when breaking a block",
      "properties": {
        "type": {
          "description": "Block or Item?",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumItemClass"
            }
          ]
        },
        "code": {
          "type": "string",
          "description": "Code of the block or item"
        },
        "quantity": {
          "description": "Quantity to be dropped",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "attributes": {
          "description": "Tree Attributes that should be attached to the resulting itemstack",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonObject"
            }
          ]
        },
        "lastDrop": {
          "type": "boolean",
          "description": "If true and the quantity dropped is &gt;=1 any subsequent drop will be ignored"
        },
        "tool": {
          "description": "If not null then given tool is required to break this block",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/EnumTool"
            }
          ]
        },
        "resolvedItemstack": {
          "description": "The resulting ItemStack for this block being broken by a tool.",
          "oneOf": [
            {
              "$ref": "#/definitions/ItemStack"
            }
          ]
        },
        "dropModbyStat": {
          "type": "string",
          "description": "If set, the drop quantity will be modified by the collecting entity stat code - entity.Stats.GetBlended(code)"
        }
      }
    },
    "NatFloat": {
      "type": "object",
      "description": "A more natural random number generator (nature usually doesn't grow by the exact same numbers nor does it completely randomly)",
      "properties": {
        "offset": {
          "type": "number",
          "format": "float"
        },
        "avg": {
          "type": "number",
          "format": "float"
        },
        "var": {
          "type": "number",
          "format": "float"
        },
        "dist": {
          "$ref": "#/definitions/EnumDistribution"
        }
      }
    },
    "EnumDistribution": {
      "type": "string",
      "description": "The distribution of the random numbers ",
      "x-enumNames": [
        "UNIFORM",
        "TRIANGLE",
        "GAUSSIAN",
        "NARROWGAUSSIAN",
        "INVERSEGAUSSIAN",
        "NARROWINVERSEGAUSSIAN",
        "INVEXP",
        "STRONGINVEXP",
        "STRONGERINVEXP",
        "DIRAC",
        "VERYNARROWGAUSSIAN"
      ],
      "enum": [
        "uniform",
        "triangle",
        "gaussian",
        "narrowgaussian",
        "inversegaussian",
        "narrowinversegaussian",
        "invexp",
        "stronginvexp",
        "strongerinvexp",
        "dirac",
        "verynarrowgaussian"
      ]
    },
    "BlockCropProperties": {
      "type": "object",
      "properties": {
        "requiredNutrient": {
          "$ref": "#/definitions/EnumSoilNutrient"
        },
        "nutrientConsumption": {
          "type": "number",
          "format": "float"
        },
        "growthStages": {
          "type": "integer",
          "format": "int32"
        },
        "totalGrowthDays": {
          "type": "number",
          "format": "float"
        },
        "multipleHarvests": {
          "type": "boolean"
        },
        "harvestGrowthStageLoss": {
          "type": "integer",
          "format": "int32"
        },
        "coldDamageBelow": {
          "type": "number",
          "format": "float"
        },
        "damageGrowthStuntMul": {
          "type": "number",
          "format": "float"
        },
        "coldDamageRipeMul": {
          "type": "number",
          "format": "float"
        },
        "heatDamageAbove": {
          "type": "number",
          "format": "float"
        },
        "behaviors": {
          "type": "array",
          "description": "Allows customization of crop growth behavior. BlockEntityFarmland calls methods on all behaviors to allow greater control.",
          "items": {
            "$ref": "#/definitions/CropBehavior"
          }
        }
      }
    },
    "EnumSoilNutrient": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "N",
        "P",
        "K"
      ],
      "enum": [
        "n",
        "p",
        "k"
      ]
    },
    "CropBehavior": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "block": {
          "$ref": "#/definitions/Block"
        }
      }
    },
    "ModelTransform": {
      "type": "object",
      "description": "Used for transformations applied to a block or item model",
      "properties": {
        "translation": {
          "description": "Offsetting",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "rotation": {
          "description": "Rotation in degrees",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "origin": {
          "description": "Rotation/Scaling Origin",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "rotate": {
          "type": "boolean",
          "description": "For Gui Transform: Whether to slowly spin in gui item preview \nFor Ground Transform: Whether to apply a random rotation to the dropped item\nNo effect on other transforms"
        },
        "scaleXYZ": {
          "description": "Scaling per axis",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "scale": {
          "type": "number",
          "description": "To set uniform Scaling on all Axes",
          "format": "float"
        },
        "asMatrix": {
          "type": "array",
          "description": "Converts the transform into a matrix.",
          "items": {
            "type": "number",
            "format": "float"
          }
        }
      }
    },
    "CombustibleProperties": {
      "type": "object",
      "description": "Used for an items combustible value",
      "properties": {
        "burnTemperature": {
          "type": "integer",
          "description": "The temperature at which it burns",
          "format": "int32"
        },
        "burnDuration": {
          "type": "number",
          "description": "For how long it burns in real life seconds",
          "format": "float"
        },
        "heatResistance": {
          "type": "integer",
          "description": "How many degrees celsius it can resists before it ignites",
          "format": "int32"
        },
        "meltingPoint": {
          "type": "integer",
          "description": "How many degrees celsius it takes to smelt/transform this into another. Only used when put in a stove and Melted is set ",
          "format": "int32"
        },
        "maxTemperature": {
          "type": "integer",
          "description": "If there is a melting point, the max temperature it can reach. Set to 0 for no limit ",
          "format": "int32"
        },
        "meltingDuration": {
          "type": "number",
          "description": "For how many seconds the temperature has to be above the melting point until the item is smelted",
          "format": "float"
        },
        "smokeLevel": {
          "type": "number",
          "description": "How much smoke this item produces when being used as fuel",
          "format": "float"
        },
        "smeltedRatio": {
          "type": "integer",
          "description": "How many ores are required to produce one output stack",
          "format": "int32"
        },
        "smeltingType": {
          "description": "Used for correct naming in the tool tip",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumSmeltType"
            }
          ]
        },
        "smeltedStack": {
          "description": "If set, the block/item is smeltable in a furnace and this is the resulting itemstack once the MeltingPoint has been reached for the supplied duration.",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        },
        "requiresContainer": {
          "type": "boolean",
          "description": "If true (default) a container is required to smelt this item. "
        }
      }
    },
    "EnumSmeltType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Smelt",
        "Cook",
        "Bake",
        "Convert",
        "Fire"
      ],
      "enum": [
        "smelt",
        "cook",
        "bake",
        "convert",
        "fire"
      ]
    },
    "FoodNutritionProperties": {
      "type": "object",
      "properties": {
        "foodCategory": {
          "description": "The category of the food.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumFoodCategory"
            }
          ]
        },
        "satiety": {
          "type": "number",
          "description": "The saturation restored by the food.",
          "format": "float"
        },
        "saturationLossDelay": {
          "type": "number",
          "description": "The delay before that extra saturation starts to go away.",
          "format": "float"
        },
        "health": {
          "type": "number",
          "description": "The health restored by the food.",
          "format": "float"
        },
        "eatenStack": {
          "description": "The item that was eaten.",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        },
        "saturation": {
          "type": "number",
          "format": "float",
          "x-deprecated": true,
          "x-deprecatedMessage": "Use Satiety instead."
        }
      }
    },
    "EnumFoodCategory": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Fruit",
        "Vegetable",
        "Protein",
        "Grain",
        "Dairy",
        "Unknown"
      ],
      "enum": [
        "fruit",
        "vegetable",
        "protein",
        "grain",
        "dairy",
        "unknown"
      ]
    },
    "TransitionableProperties": {
      "type": "object",
      "properties": {
        "type": {
          "description": "What kind of transition can it make?",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumTransitionType"
            }
          ]
        },
        "freshHours": {
          "description": "The amount of hours this item stays fresh / untransitioned",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "transitionHours": {
          "description": "The amount of hours it takes for the item to transition",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "transitionedStack": {
          "description": "The itemstack the item/block turns into upon transitioning",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        },
        "transitionRatio": {
          "type": "number",
          "description": "Conversion ratio of fresh stacksize to transitioned stack size",
          "format": "float"
        }
      }
    },
    "EnumTransitionType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Perish",
        "Dry",
        "Burn",
        "Cure",
        "Convert",
        "Ripen"
      ],
      "enum": [
        "perish",
        "dry",
        "burn",
        "cure",
        "convert",
        "ripen"
      ]
    },
    "GrindingProperties": {
      "type": "object",
      "properties": {
        "groundStack": {
          "description": "If set, the block/item is grindable in a quern and this is the resulting itemstack once the grinding time is over.",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        },
        "grindedStack": {
          "x-deprecated": true,
          "x-deprecatedMessage": "Use GroundStack instead",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        }
      }
    },
    "CrushingProperties": {
      "type": "object",
      "properties": {
        "crushedStack": {
          "description": "If set, the block/item is crusable in a pulverizer and this is the resulting itemstack once the crushing time is over.",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        },
        "hardnessTier": {
          "type": "integer",
          "description": "0 = stone, 1 = copper, 2 = bronze, 3 = iron, 4 = steel",
          "format": "int32"
        }
      }
    },
    "AdvancedParticleProperties": {
      "type": "object",
      "properties": {
        "hsvaColor": {
          "type": "array",
          "description": "The Hue/Saturation/Value/Alpha for the color of the particle.",
          "items": {
            "$ref": "#/definitions/NatFloat"
          }
        },
        "posOffset": {
          "type": "array",
          "description": "Offset from the blocks hitboxes top middle position",
          "items": {
            "$ref": "#/definitions/NatFloat"
          }
        },
        "basePos": {
          "description": "The base position for the particles.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "baseVelocity": {
          "$ref": "#/definitions/Vec3f"
        },
        "block": {
          "description": "The base block for the particle.",
          "oneOf": [
            {
              "$ref": "#/definitions/Block"
            }
          ]
        },
        "color": {
          "type": "integer",
          "description": "When HsvaColor is null, this is used",
          "format": "int32"
        },
        "randomVelocityChange": {
          "type": "boolean"
        },
        "dieOnRainHeightmap": {
          "type": "boolean"
        },
        "secondaryParticles": {
          "type": "array",
          "description": "The Secondary particles for the JsonObject.",
          "items": {
            "$ref": "#/definitions/AdvancedParticleProperties"
          }
        },
        "deathParticles": {
          "type": "array",
          "description": "The death particles for the JsonObject.",
          "items": {
            "$ref": "#/definitions/AdvancedParticleProperties"
          }
        },
        "secondarySpawnInterval": {
          "description": "The inverval that the secondary particles spawn.",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "bouncy": {
          "type": "boolean"
        },
        "dieInAir": {
          "type": "boolean",
          "description": "Whether or not the entity dies in air."
        },
        "dieInLiquid": {
          "type": "boolean",
          "description": "Whether or not the entity dies in water."
        },
        "swimOnLiquid": {
          "type": "boolean"
        },
        "colorByBlock": {
          "type": "boolean",
          "description": "Whether or not to color the particle by the block it's on."
        },
        "opacityEvolve": {
          "description": "a transforming opacity value.",
          "oneOf": [
            {
              "$ref": "#/definitions/EvolvingNatFloat"
            }
          ]
        },
        "redEvolve": {
          "description": "A transforming Red value.",
          "oneOf": [
            {
              "$ref": "#/definitions/EvolvingNatFloat"
            }
          ]
        },
        "greenEvolve": {
          "description": "A transforming Green value.",
          "oneOf": [
            {
              "$ref": "#/definitions/EvolvingNatFloat"
            }
          ]
        },
        "blueEvolve": {
          "description": "A transforming Blue value.",
          "oneOf": [
            {
              "$ref": "#/definitions/EvolvingNatFloat"
            }
          ]
        },
        "gravityEffect": {
          "description": "The gravity effect on the particle.",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "lifeLength": {
          "description": "The life length of the particle.",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "quantity": {
          "description": "The quantity of the particles given.",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "size": {
          "description": "The size of the particles given.",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "sizeEvolve": {
          "description": "a transforming Size value.",
          "oneOf": [
            {
              "$ref": "#/definitions/EvolvingNatFloat"
            }
          ]
        },
        "velocity": {
          "type": "array",
          "description": "The velocity of the particles.",
          "items": {
            "$ref": "#/definitions/NatFloat"
          }
        },
        "velocityEvolve": {
          "type": "array",
          "description": "A dynamic velocity value.",
          "items": {
            "$ref": "#/definitions/EvolvingNatFloat"
          }
        },
        "particleModel": {
          "description": "Sets the base model for the particle.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumParticleModel"
            }
          ]
        },
        "vertexFlags": {
          "type": "integer",
          "description": "The level of glow in the particle.",
          "format": "int32"
        },
        "selfPropelled": {
          "type": "boolean",
          "description": "Whether or not the particle is self propelled."
        },
        "terrainCollision": {
          "type": "boolean",
          "description": "Whether or not the particle collides with the terrain."
        },
        "windAffectednes": {
          "type": "number",
          "format": "float"
        },
        "pos": {
          "$ref": "#/definitions/Vec3d"
        },
        "parentVelocity": {
          "$ref": "#/definitions/Vec3f"
        },
        "windAffectednesAtPos": {
          "type": "number",
          "format": "float"
        },
        "parentVelocityWeight": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "EvolvingNatFloat": {
      "type": "object",
      "description": "A number generator whose return value changes over time, parametrized by a transform function and some constants",
      "properties": {
        "factor": {
          "type": "number",
          "format": "float"
        },
        "maxValue": {
          "type": [
            "null",
            "number"
          ],
          "format": "float"
        },
        "transform": {
          "$ref": "#/definitions/EnumTransformFunction"
        }
      }
    },
    "EnumTransformFunction": {
      "type": "string",
      "description": "Used for EvolvingNatFloat value transforms",
      "x-enumNames": [
        "IDENTICAL",
        "LINEAR",
        "LINEARNULLIFY",
        "LINEARREDUCE",
        "LINEARINCREASE",
        "QUADRATIC",
        "INVERSELINEAR",
        "ROOT",
        "SINUS",
        "CLAMPEDPOSITIVESINUS",
        "COSINUS",
        "SMOOTHSTEP"
      ],
      "enum": [
        "identical",
        "linear",
        "linearnullify",
        "linearreduce",
        "linearincrease",
        "quadratic",
        "inverselinear",
        "root",
        "sinus",
        "clampedpositivesinus",
        "cosinus",
        "smoothstep"
      ]
    },
    "EnumParticleModel": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Quad",
        "Cube"
      ],
      "enum": [
        "quad",
        "cube"
      ]
    },
    "EnumItemStorageFlags": {
      "type": "string",
      "description": "Determines the kinds of storage types the item can be put into",
      "x-enumFlags": true,
      "x-enumNames": [
        "General",
        "Backpack",
        "Metallurgy",
        "Jewellery",
        "Alchemy",
        "Agriculture",
        "Currency",
        "Outfit",
        "Offhand",
        "Arrow",
        "Reserved2",
        "Custom1",
        "Custom2",
        "Custom3",
        "Custom4",
        "Custom5",
        "Custom6",
        "Custom7",
        "Custom8",
        "Custom9",
        "Custom10"
      ],
      "enum": [
        "general",
        "backpack",
        "metallurgy",
        "jewellery",
        "alchemy",
        "agriculture",
        "currency",
        "outfit",
        "offhand",
        "arrow",
        "reserved2",
        "custom1",
        "custom2",
        "custom3",
        "custom4",
        "custom5",
        "custom6",
        "custom7",
        "custom8",
        "custom9",
        "custom10"
      ]
    },
    "RegistryObject": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "code": {
          "type": "string",
          "description": "A unique domain + code of the object. Must be globally unique for all items / all blocks / all entities."
        },
        "variantStrict": {
          "description": "Variant values as resolved from blocktype/itemtype or entitytype",
          "oneOf": [
            {
              "$ref": "#/definitions/OrderedDictionaryOfStringAndString"
            }
          ]
        },
        "variant": {
          "description": "Variant values as resolved from blocktype/itemtype or entitytype. Will not throw an null pointer exception when the key does not exist, but return null instead.",
          "oneOf": [
            {
              "$ref": "#/definitions/RelaxedReadOnlyDictionaryOfStringAndString"
            }
          ]
        },
        "class": {
          "type": "string",
          "description": "The class handeling the object"
        }
      }
    },
    "OrderedDictionaryOfStringAndString": {
      "type": "object",
      "description": "Same as your normal C# Dictionary but ensures that the order in which the items are added is remembered. That way you can iterate over the dictionary with the insert order intact or set/get elements by index.\nTaken from http://www.codeproject.com/Articles/18615/OrderedDictionary-T-A-generic-implementation-of-IO\nPlease be aware that this is not a very efficient implementation, recommed use only for small sets of data.",
      "properties": {
        "InternalDictionary": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "Item": {
          "type": "string"
        },
        "Count": {
          "type": "integer",
          "format": "int32"
        },
        "Keys": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "ValuesOrdered": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "Values": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "IsReadOnly": {
          "type": "boolean"
        }
      }
    },
    "RelaxedReadOnlyDictionaryOfStringAndString": {
      "type": "object",
      "properties": {
        "Item": {
          "type": "string"
        },
        "Keys": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "Values": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "Count": {
          "type": "integer",
          "format": "int32"
        },
        "IsReadOnly": {
          "type": "boolean"
        }
      }
    },
    "EntityProperties": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "The entity code in the code."
        },
        "variant": {
          "description": "Variant values as resolved from blocktype/itemtype or entitytype",
          "oneOf": [
            {
              "$ref": "#/definitions/OrderedDictionaryOfStringAndString"
            }
          ]
        },
        "class": {
          "type": "string",
          "description": "The classification of the entity."
        },
        "habitat": {
          "description": "Natural habitat of the entity. Decides whether to apply gravity or not",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumHabitat"
            }
          ]
        },
        "hitBoxSize": {
          "description": "The size of the entity's hitbox (default: 0.2f/0.2f)",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec2f"
            }
          ]
        },
        "deadHitBoxSize": {
          "description": "The size of the hitbox while the entity is dead.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec2f"
            }
          ]
        },
        "eyeHeight": {
          "type": "number",
          "description": "How high the camera should be placed if this entity were to be controlled by the player",
          "format": "double"
        },
        "weight": {
          "type": "number",
          "description": "The mass of this type of entity in kilograms, on average - defaults to 25kg (medium-low) if not set by the asset",
          "format": "float"
        },
        "canClimb": {
          "type": "boolean",
          "description": "If true the entity can climb on walls"
        },
        "canClimbAnywhere": {
          "type": "boolean",
          "description": "If true the entity can climb anywhere."
        },
        "fallDamage": {
          "type": "boolean",
          "description": "Whether the entity should take fall damage"
        },
        "climbTouchDistance": {
          "type": "number",
          "format": "float"
        },
        "rotateModelOnClimb": {
          "type": "boolean",
          "description": "Should the model in question rotate if climbing?"
        },
        "knockbackResistance": {
          "type": "number",
          "description": "The resistance to being pushed back by an impact.",
          "format": "float"
        },
        "attributes": {
          "description": "The attributes of the entity.",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonObject"
            }
          ]
        },
        "client": {
          "description": "The client properties of the entity.",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityClientProperties"
            }
          ]
        },
        "server": {
          "description": "The server properties of the entity.",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityServerProperties"
            }
          ]
        },
        "sounds": {
          "type": "object",
          "description": "The sounds that this entity can make.",
          "additionalProperties": {
            "type": "string"
          }
        },
        "resolvedSounds": {
          "type": "object",
          "description": "The sounds this entity can make after being resolved.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "idleSoundChance": {
          "type": "number",
          "description": "The chance that an idle sound will play for the entity.",
          "format": "float"
        },
        "idleSoundRange": {
          "type": "number",
          "description": "The sound range for the idle sound in blocks.",
          "format": "float"
        },
        "drops": {
          "type": "array",
          "description": "The drops for the entity when they are killed.",
          "items": {
            "$ref": "#/definitions/BlockDropItemStack"
          }
        },
        "spawnCollisionBox": {
          "description": "The collision box they have.",
          "oneOf": [
            {
              "$ref": "#/definitions/Cuboidf"
            }
          ]
        }
      }
    },
    "EnumHabitat": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Sea",
        "Land",
        "Air",
        "Underwater"
      ],
      "enum": [
        "sea",
        "land",
        "air",
        "underwater"
      ]
    },
    "Vec2f": {
      "type": "object",
      "description": "Represents a vector of 2 floats. Go bug Tyron of you need more utility methods in this class.",
      "properties": {
        "x": {
          "type": "number",
          "format": "float"
        },
        "y": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "EntityClientProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/EntitySidedProperties"
        },
        {
          "type": "object",
          "properties": {
            "renderer": {
              "description": "Set by the game client",
              "oneOf": [
                {
                  "$ref": "#/definitions/EntityRenderer"
                }
              ]
            },
            "rendererName": {
              "type": "string",
              "description": "Name of there renderer system that draws this entity"
            },
            "textures": {
              "type": "object",
              "description": "Directory of all available textures. First one will be default one",
              "additionalProperties": {
                "$ref": "#/definitions/CompositeTexture"
              }
            },
            "glowLevel": {
              "type": "integer",
              "description": "The glow level for the entity.",
              "format": "int32"
            },
            "shape": {
              "description": "The shape of the entity",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeShape"
                }
              ]
            },
            "loadedShape": {
              "description": "Only loaded for World.EntityTypes instances of EntityProperties, because it makes no sense to have 1000 loaded entities needing to load 1000 shapes. During entity load/spawn this value is assigned however\nOn the client it gets set by the EntityTextureAtlasManager\nOn the server by the EntitySimulation system",
              "oneOf": [
                {
                  "$ref": "#/definitions/Shape"
                }
              ]
            },
            "size": {
              "type": "number",
              "description": "The size of the entity (default: 1f)",
              "format": "float"
            },
            "sizeGrowthFactor": {
              "type": "number",
              "description": "The rate at which the entity's size grows with age - used for chicks and other small baby animals",
              "format": "float"
            },
            "animations": {
              "type": "array",
              "description": "The animations of the entity.",
              "items": {
                "$ref": "#/definitions/AnimationMetaData"
              }
            },
            "animationsByMetaCode": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/AnimationMetaData"
              }
            },
            "animationsByCrc32": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/AnimationMetaData"
              }
            },
            "texture": {
              "description": "Used by various renderers to retrieve the entities texture it should be drawn with",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeTexture"
                }
              ]
            },
            "firstTexture": {
              "description": "Returns the first texture in Textures dict",
              "oneOf": [
                {
                  "$ref": "#/definitions/CompositeTexture"
                }
              ]
            }
          }
        }
      ]
    },
    "EntityRenderer": {
      "type": "object",
      "description": "Base class for entity rendering",
      "x-abstract": true,
      "properties": {
        "entity": {
          "description": "The current entity",
          "oneOf": [
            {
              "$ref": "#/definitions/Entity"
            }
          ]
        },
        "capi": {
          "description": "A reference to the client api",
          "oneOf": [
            {
              "$ref": "#/definitions/ICoreClientAPI"
            }
          ]
        }
      }
    },
    "Entity": {
      "allOf": [
        {
          "$ref": "#/definitions/RegistryObject"
        },
        {
          "type": "object",
          "description": "The basic class for all entities in the game",
          "x-abstract": true,
          "properties": {
            "world": {
              "description": "World where the entity is spawned in. Available on the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/IWorldAccessor"
                }
              ]
            },
            "api": {
              "description": "The api, if you need it. Available on the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/ICoreAPI"
                }
              ]
            },
            "physicsUpdateWatcher": {
              "description": "The vanilla physics systems will call this method if a physics behavior was assigned to it. The game client for example requires this to be called for the current player to properly render the player. Available on the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/PhysicsTickDelegate"
                }
              ]
            },
            "animManager": {
              "description": "Server simulated animations. Only takes care of stopping animations once they're done\nSet and Called by the Entities ServerSystem",
              "oneOf": [
                {
                  "$ref": "#/definitions/IAnimationManager"
                }
              ]
            },
            "activityTimers": {
              "type": "object",
              "description": "An uptime value running activities. Available on the game client and server. Not synchronized.",
              "additionalProperties": {
                "type": "integer",
                "format": "int64"
              }
            },
            "pos": {
              "description": "Client position",
              "oneOf": [
                {
                  "$ref": "#/definitions/SyncedEntityPos"
                }
              ]
            },
            "serverPos": {
              "description": "Server simulated position. May not exactly match the client positon",
              "oneOf": [
                {
                  "$ref": "#/definitions/EntityPos"
                }
              ]
            },
            "previousServerPos": {
              "description": "Server simulated position copy. Needed by Entities server system to send pos updatess only if ServerPos differs noticably from PreviousServerPos",
              "oneOf": [
                {
                  "$ref": "#/definitions/EntityPos"
                }
              ]
            },
            "positionBeforeFalling": {
              "description": "The position where the entity last had contact with the ground. Set by the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Vec3d"
                }
              ]
            },
            "inChunkIndex3d": {
              "type": "integer",
              "format": "int64"
            },
            "collisionBox": {
              "description": "The entities collision box. Offseted by the animation system when necessary. Set by the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Cuboidf"
                }
              ]
            },
            "originCollisionBox": {
              "description": "The entities collision box. Not Offseted. Set by the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Cuboidf"
                }
              ]
            },
            "teleporting": {
              "type": "boolean",
              "description": "Used by the teleporter block"
            },
            "isTeleport": {
              "type": "boolean",
              "description": "Used by the server to tell connected clients that the next entity position packet should not have its position change get interpolated. Gets set to false after the packet was sent"
            },
            "entityId": {
              "type": "integer",
              "description": "A unique identifier for this entity. Set by the game client and server.",
              "format": "int64"
            },
            "simulationRange": {
              "type": "integer",
              "description": "The range in blocks the entity has to be to a client to do physics and AI. When outside range, then  will be set to inactive",
              "format": "int32"
            },
            "climbingOnFace": {
              "description": "The face the entity is climbing on. Null if the entity is not climbing. Set by the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/BlockFacing"
                }
              ]
            },
            "climbingOnCollBox": {
              "description": "Set by the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Cuboidf"
                }
              ]
            },
            "onGround": {
              "type": "boolean",
              "description": "True if this entity is in touch with the ground. Set by the game client and server."
            },
            "feetInLiquid": {
              "type": "boolean",
              "description": "True if the bottom of the collisionbox is inside a liquid. Set by the game client and server."
            },
            "inLava": {
              "type": "boolean"
            },
            "inLavaBeginTotalMs": {
              "type": "integer",
              "format": "int64"
            },
            "onFireBeginTotalMs": {
              "type": "integer",
              "format": "int64"
            },
            "swimming": {
              "type": "boolean",
              "description": "True if the collisionbox is 2/3rds submerged in liquid. Set by the game client and server."
            },
            "collidedVertically": {
              "type": "boolean",
              "description": "True if the entity is in touch with something solid on the vertical axis. Set by the game client and server."
            },
            "collidedHorizontally": {
              "type": "boolean",
              "description": "True if the entity is in touch with something solid on both horizontal axes. Set by the game client and server."
            },
            "state": {
              "description": "The current entity state. Stored in WatchedAttributes in from/tobytes, so available on the client and server side",
              "oneOf": [
                {
                  "$ref": "#/definitions/EnumEntityState"
                }
              ]
            },
            "despawnReason": {
              "$ref": "#/definitions/EntityDespawnReason"
            },
            "watchedAttributes": {
              "description": "Permanently stored entity attributes that are sent to client everytime they have been changed",
              "oneOf": [
                {
                  "$ref": "#/definitions/SyncedTreeAttribute"
                }
              ]
            },
            "debugAttributes": {
              "description": "If entity debug mode is on, this info will be transitted to client and displayed above the entities head",
              "oneOf": [
                {
                  "$ref": "#/definitions/SyncedTreeAttribute"
                }
              ]
            },
            "attributes": {
              "description": "Permanently stored entity attributes that are only client or only server side",
              "oneOf": [
                {
                  "$ref": "#/definitions/SyncedTreeAttribute"
                }
              ]
            },
            "isRendered": {
              "type": "boolean",
              "description": "Set by the client renderer when the entity was rendered last frame"
            },
            "isShadowRendered": {
              "type": "boolean",
              "description": "Set by the client renderer when the entity shadow was rendered last frame"
            },
            "stats": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/KeyValuePairOfStringAndEntityFloatStats"
              }
            },
            "isOnFire": {
              "type": "boolean"
            },
            "properties": {
              "$ref": "#/definitions/EntityProperties"
            },
            "sidedProperties": {
              "$ref": "#/definitions/EntitySidedProperties"
            },
            "isInteractable": {
              "type": "boolean",
              "description": "Should return true when this entity should be interactable by a player or other entities"
            },
            "swimmingOffsetY": {
              "type": "number",
              "description": "Used for passive physics simulation, together with the MaterialDensity to check how deep in the water the entity should float",
              "format": "double"
            },
            "collided": {
              "type": "boolean",
              "description": "CollidedVertically || CollidedHorizontally"
            },
            "sidedPos": {
              "description": "ServerPos on server, Pos on client",
              "oneOf": [
                {
                  "$ref": "#/definitions/EntityPos"
                }
              ]
            },
            "localEyePos": {
              "description": "The height of the eyes for the given entity.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Vec3d"
                }
              ]
            },
            "applyGravity": {
              "type": "boolean",
              "description": "If gravity should applied to this entity"
            },
            "materialDensity": {
              "type": "number",
              "description": "Determines on whether an entity floats on liquids or not and how strongly items get pushed by water. Water has a density of 1000.\nA density below 1000 means the entity floats on top of water if has a physics simulation behavior attached to it.",
              "format": "float"
            },
            "lightHsv": {
              "type": "string",
              "description": "If set, the entity will emit dynamic light",
              "format": "byte"
            },
            "shouldDespawn": {
              "type": "boolean",
              "description": "If the entity should despawn next server tick. By default returns !Alive for non-creatures and creatures that don't have a Decay behavior"
            },
            "storeWithChunk": {
              "type": "boolean",
              "description": "Players and whatever the player rides on will be stored seperatly"
            },
            "alwaysActive": {
              "type": "boolean",
              "description": "Whether this entity should always stay in Active model, regardless on how far away other player are"
            },
            "alive": {
              "type": "boolean",
              "description": "True if the entity is in state active or inactive"
            },
            "idleSoundChanceModifier": {
              "type": "number",
              "format": "float"
            },
            "renderColor": {
              "type": "integer",
              "description": "Used by some renderers to apply an overal color tint on the entity",
              "format": "int32"
            },
            "ladderFixDelta": {
              "type": "number",
              "description": "A small offset used to prevent players from clipping through the blocks above ladders: relevant if the entity's collision box is sometimes adjusted by the game code",
              "format": "double"
            }
          }
        }
      ]
    },
    "PhysicsTickDelegate": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "IAnimationManager": {
      "type": "object",
      "description": "Everything needed for allowing animations the Entity class holds a reference to an IAnimator. \nCurrently implemented by ServerAnimator",
      "x-abstract": true,
      "properties": {
        "animator": {
          "description": "The animator for this animation manager",
          "oneOf": [
            {
              "$ref": "#/definitions/IAnimator"
            }
          ]
        },
        "headController": {
          "description": "The head controller for this manager.",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityHeadController"
            }
          ]
        },
        "animationsDirty": {
          "type": "boolean",
          "description": "Whether or not the animation is dirty."
        },
        "activeAnimationsByAnimCode": {
          "type": "object",
          "description": "Gets the AnimationMetaData for the target action.",
          "additionalProperties": {
            "$ref": "#/definitions/AnimationMetaData"
          }
        }
      }
    },
    "IAnimator": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "matrices": {
          "type": "array",
          "description": "The 30 pose transformation matrices that go to the shader",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "activeAnimationCount": {
          "type": "integer",
          "description": "Amount of currently active animations",
          "format": "int32"
        },
        "runningAnimations": {
          "type": "array",
          "description": "Holds data over all animations. This list always contains all animations of the creature. You have to check yourself which of them are active",
          "items": {
            "$ref": "#/definitions/RunningAnimation"
          }
        },
        "calculateMatrices": {
          "type": "boolean",
          "description": "Whether or not to calculate the animation matrices, required for GetAttachmentPointPose() to deliver correct values. Default on on the client, server side only on when the creature is dead"
        }
      }
    },
    "RunningAnimation": {
      "type": "object",
      "properties": {
        "meta": {
          "$ref": "#/definitions/AnimationMetaData"
        },
        "currentFrame": {
          "type": "number",
          "format": "float"
        },
        "animation": {
          "$ref": "#/definitions/Animation"
        },
        "active": {
          "type": "boolean"
        },
        "running": {
          "type": "boolean"
        },
        "iterations": {
          "type": "integer",
          "format": "int32"
        },
        "shouldRewind": {
          "type": "boolean"
        },
        "shouldPlayTillEnd": {
          "type": "boolean"
        },
        "easingFactor": {
          "type": "number",
          "format": "float"
        },
        "blendedWeight": {
          "type": "number",
          "format": "float"
        },
        "elementWeights": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ShapeElementWeights"
          }
        }
      }
    },
    "AnimationMetaData": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "Unique identifier to be able to reference this AnimationMetaData instance"
        },
        "animation": {
          "type": "string",
          "description": "The animations code identifier that we want to play"
        },
        "weight": {
          "type": "number",
          "format": "float"
        },
        "elementWeight": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "float"
          }
        },
        "animationSpeed": {
          "type": "number",
          "format": "float"
        },
        "mulWithWalkSpeed": {
          "type": "boolean"
        },
        "easeInSpeed": {
          "type": "number",
          "description": "A multiplier applied to the weight value to \"ease in\" the animation. Choose a high value for looping animations or it will be glitchy",
          "format": "float"
        },
        "easeOutSpeed": {
          "type": "number",
          "description": "A multiplier applied to the weight value to \"ease out\" the animation. Choose a high value for looping animations or it will be glitchy",
          "format": "float"
        },
        "triggeredBy": {
          "$ref": "#/definitions/AnimationTrigger"
        },
        "blendMode": {
          "$ref": "#/definitions/EnumAnimationBlendMode"
        },
        "elementBlendMode": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/EnumAnimationBlendMode"
          }
        },
        "supressDefaultAnimation": {
          "type": "boolean"
        },
        "holdEyePosAfterEasein": {
          "type": "number",
          "format": "float"
        },
        "startFrameOnce": {
          "type": "number",
          "format": "float"
        },
        "codeCrc32": {
          "type": "integer"
        },
        "wasStartedFromTrigger": {
          "type": "boolean"
        }
      }
    },
    "AnimationTrigger": {
      "type": "object",
      "properties": {
        "onControls": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EnumEntityActivity"
          }
        },
        "matchExact": {
          "type": "boolean"
        },
        "defaultAnim": {
          "type": "boolean"
        }
      }
    },
    "EnumEntityActivity": {
      "type": "string",
      "description": "",
      "x-enumFlags": true,
      "x-enumNames": [
        "None",
        "Idle",
        "Move",
        "SprintMode",
        "SneakMode",
        "Fly",
        "Swim",
        "Jump",
        "Fall",
        "Climb",
        "FloorSitting",
        "Dead",
        "Break",
        "Place"
      ],
      "enum": [
        "none",
        "idle",
        "move",
        "sprintMode",
        "sneakMode",
        "fly",
        "swim",
        "jump",
        "fall",
        "climb",
        "floorSitting",
        "dead",
        "break",
        "place"
      ]
    },
    "EnumAnimationBlendMode": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Add",
        "Average",
        "AddAverage"
      ],
      "enum": [
        "add",
        "average",
        "addAverage"
      ]
    },
    "Animation": {
      "type": "object",
      "description": "Represents a shape animation and can calculate the transformation matrices for each frame to be sent to the shader\nProcess\n1. For each frame, for each root element, calculate the transformation matrix. Curent model matrix is identy mat.\n1.1. Get previous and next key frame. Apply translation, rotation and scale to model matrix.\n1.2. Store this matrix as animationmatrix in list\n1.3. For each child element\n1.3.1. Multiply local transformation matrix with the animation matrix. This matrix is now the curent model matrix. Go to 1 with child elements as root elems\n\n2. For each frame, for each joint\n2.1. Calculate the inverse model matrix \n2.2. Multiply stored animationmatrix with the inverse model matrix\n\n3. done",
      "properties": {
        "quantityFrames": {
          "type": "integer",
          "format": "int32"
        },
        "name": {
          "type": "string"
        },
        "code": {
          "type": "string"
        },
        "keyFrames": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AnimationKeyFrame"
          }
        },
        "onActivityStopped": {
          "$ref": "#/definitions/EnumEntityActivityStoppedHandling"
        },
        "onAnimationEnd": {
          "$ref": "#/definitions/EnumEntityAnimationEndHandling"
        },
        "codeCrc32": {
          "type": "integer"
        },
        "prevNextKeyFrameByFrame": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/AnimationFrame"
            }
          }
        }
      }
    },
    "AnimationKeyFrame": {
      "type": "object",
      "properties": {
        "frame": {
          "type": "integer",
          "description": "The ID of the keyframe.",
          "format": "int32"
        },
        "elements": {
          "type": "object",
          "description": "The elements of the keyframe.",
          "additionalProperties": {
            "$ref": "#/definitions/AnimationKeyFrameElement"
          }
        }
      }
    },
    "AnimationKeyFrameElement": {
      "type": "object",
      "properties": {
        "offsetX": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "offsetY": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "offsetZ": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "stretchX": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "stretchY": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "stretchZ": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "rotationX": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "rotationY": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "rotationZ": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "originX": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "originY": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "originZ": {
          "type": [
            "null",
            "number"
          ],
          "format": "double"
        },
        "forElement": {
          "$ref": "#/definitions/ShapeElement"
        },
        "anySet": {
          "type": "boolean"
        },
        "positionSet": {
          "type": "boolean"
        },
        "stretchSet": {
          "type": "boolean"
        },
        "rotationSet": {
          "type": "boolean"
        },
        "originSet": {
          "type": "boolean"
        }
      }
    },
    "ShapeElement": {
      "type": "object",
      "description": "A shape element built from JSON data within the model.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the ShapeElement"
        },
        "from": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "to": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "shade": {
          "type": "boolean",
          "description": "Whether or not the shape element is shaded."
        },
        "gradientShade": {
          "type": "boolean"
        },
        "faces": {
          "type": "object",
          "description": "The faces of the shape element by name.",
          "additionalProperties": {
            "$ref": "#/definitions/ShapeElementFace"
          }
        },
        "rotationOrigin": {
          "type": "array",
          "description": "The origin point for rotation.",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "rotationX": {
          "type": "number",
          "description": "The forward vertical rotation of the shape element.",
          "format": "double"
        },
        "rotationY": {
          "type": "number",
          "description": "The forward vertical rotation of the shape element.",
          "format": "double"
        },
        "rotationZ": {
          "type": "number",
          "description": "The left/right tilt of the shape element",
          "format": "double"
        },
        "scaleX": {
          "type": "number",
          "description": "How far away are the left/right sides of the shape from the center",
          "format": "double"
        },
        "scaleY": {
          "type": "number",
          "description": "How far away are the top/bottom sides of the shape from the center",
          "format": "double"
        },
        "scaleZ": {
          "type": "number",
          "description": "How far away are the front/back sides of the shape from the center.",
          "format": "double"
        },
        "climateColorMap": {
          "type": "string"
        },
        "seasonColorMap": {
          "type": "string"
        },
        "renderPass": {
          "type": "integer"
        },
        "zOffset": {
          "type": "integer"
        },
        "foliageWindWave": {
          "type": "boolean",
          "description": "This will set the FoliageWindWave flag in the sourceMesh when the shape is originally tesselated, but note that all/most Block.OnJsonTesselation methods will reset this flag in the sourceMesh using VertexFlags.clearbits (and always reset if the block is rendered underground or indoors with windwave off)"
        },
        "weakWave": {
          "type": "boolean"
        },
        "waterWave": {
          "type": "boolean"
        },
        "reflective": {
          "type": "boolean"
        },
        "disableRandomDrawOffset": {
          "type": "boolean",
          "description": "Set this to true to disable randomDrawOffset and randomRotations on this specific element (e.g. used for the ice element of Coopers Reeds in Ice)"
        },
        "foliageWaveSpecial": {
          "type": "integer",
          "description": "Only meaningful if the block or element applies the FoliageWindWave flag.  This uses the GroundDistance bits (otherwise only used by LeavesWindWave) to ask the shader for a special form of FoliageWindWave.\n  0: standard foliage wave\n  1: stiffer foliage, lower frequency wave\n  3: sway and bend (rotate) in the wind but do not change shape - e.g. used for pineapple crop central stalk and fruit - note the rotation origin is hard-coded to (x,z) = (0.5, 0.5)\n  4: move laterally with the sway/bend motion in 3, but apply leaf shimmer as well - e.g. used for pineapple crop flower and calyx (leaves below fruit)"
        },
        "children": {
          "type": "array",
          "description": "The child shapes of this shape element",
          "items": {
            "$ref": "#/definitions/ShapeElement"
          }
        },
        "attachmentPoints": {
          "type": "array",
          "description": "The attachment points for this shape.",
          "items": {
            "$ref": "#/definitions/AttachmentPoint"
          }
        },
        "stepParentName": {
          "type": "string",
          "description": "The \"remote\" parent for this element"
        },
        "parentElement": {
          "description": "The parent element reference for this shape.",
          "oneOf": [
            {
              "$ref": "#/definitions/ShapeElement"
            }
          ]
        },
        "jointId": {
          "type": "integer",
          "description": "The id of the joint attached to the parent element.",
          "format": "int32"
        },
        "inverseModelTransform": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        }
      }
    },
    "ShapeElementFace": {
      "type": "object",
      "properties": {
        "texture": {
          "type": "string",
          "description": "The texture of the face."
        },
        "uv": {
          "type": "array",
          "description": "The UV array of the face.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "rotation": {
          "type": "number",
          "description": "The rotation of the face.",
          "format": "float"
        },
        "glow": {
          "type": "integer",
          "description": "The glow on the face.",
          "format": "int32"
        },
        "enabled": {
          "type": "boolean",
          "description": "Whether or not the element is enabled."
        }
      }
    },
    "AttachmentPoint": {
      "type": "object",
      "description": "This is a spot on the shape that connects to another shape.",
      "properties": {
        "parentElement": {
          "description": "The parent element of this attachment point.",
          "oneOf": [
            {
              "$ref": "#/definitions/ShapeElement"
            }
          ]
        },
        "code": {
          "type": "string",
          "description": "The json code of this attachment point."
        },
        "posX": {
          "type": "number",
          "description": "The X position of the attachment point.",
          "format": "double"
        },
        "posY": {
          "type": "number",
          "description": "The Y position of the attachment point.",
          "format": "double"
        },
        "posZ": {
          "type": "number",
          "description": "The Z position of the attachment point.",
          "format": "double"
        },
        "rotationX": {
          "type": "number",
          "description": "The forward vertical rotation of the attachment point.",
          "format": "double"
        },
        "rotationY": {
          "type": "number",
          "description": "The forward horizontal rotation of the attachment point",
          "format": "double"
        },
        "rotationZ": {
          "type": "number",
          "description": "the left/right tilt of the attachment point",
          "format": "double"
        }
      }
    },
    "EnumEntityActivityStoppedHandling": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "PlayTillEnd",
        "Rewind",
        "Stop",
        "EaseOut"
      ],
      "enum": [
        "playTillEnd",
        "rewind",
        "stop",
        "easeOut"
      ]
    },
    "EnumEntityAnimationEndHandling": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Repeat",
        "Hold",
        "Stop"
      ],
      "enum": [
        "repeat",
        "hold",
        "stop"
      ]
    },
    "AnimationFrame": {
      "type": "object",
      "properties": {
        "frameNumber": {
          "type": "integer",
          "description": "The frame number.",
          "format": "int32"
        },
        "animTransforms": {
          "type": "array",
          "description": "The transformations for this frame.",
          "items": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        },
        "transformationMatrices": {
          "type": "array",
          "description": "The transformation matricies for this frame",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "rootElementTransforms": {
          "type": "array",
          "description": "The transformations for the root element of the frame.",
          "items": {
            "$ref": "#/definitions/ElementPose"
          }
        }
      }
    },
    "ElementPose": {
      "type": "object",
      "description": "The position of an element.",
      "properties": {
        "forElement": {
          "description": "The element this positioning is for.",
          "oneOf": [
            {
              "$ref": "#/definitions/ShapeElement"
            }
          ]
        },
        "animModelMatrix": {
          "type": "array",
          "description": "The model matrix of this element.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "childElementPoses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElementPose"
          }
        },
        "degX": {
          "type": "number",
          "format": "float"
        },
        "degY": {
          "type": "number",
          "format": "float"
        },
        "degZ": {
          "type": "number",
          "format": "float"
        },
        "scaleX": {
          "type": "number",
          "format": "float"
        },
        "scaleY": {
          "type": "number",
          "format": "float"
        },
        "scaleZ": {
          "type": "number",
          "format": "float"
        },
        "translateX": {
          "type": "number",
          "format": "float"
        },
        "translateY": {
          "type": "number",
          "format": "float"
        },
        "translateZ": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "ShapeElementWeights": {
      "type": "object",
      "properties": {
        "weight": {
          "type": "number",
          "format": "float"
        },
        "blendMode": {
          "$ref": "#/definitions/EnumAnimationBlendMode"
        },
        "childElements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ShapeElementWeights"
          }
        }
      }
    },
    "EntityHeadController": {
      "type": "object",
      "properties": {
        "headElement": {
          "$ref": "#/definitions/ShapeElement"
        },
        "neckElement": {
          "$ref": "#/definitions/ShapeElement"
        }
      }
    },
    "SyncedEntityPos": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityPos"
        },
        {
          "type": "object",
          "description": "Represents an EntityPos thats synced over the network using a dirty flag and regular is-dirty checks",
          "properties": {
            "lastReceivedClientPosition": {
              "type": "integer",
              "format": "int64"
            },
            "x": {
              "type": "number",
              "format": "double"
            },
            "y": {
              "type": "number",
              "format": "double"
            },
            "z": {
              "type": "number",
              "format": "double"
            },
            "roll": {
              "type": "number",
              "format": "float"
            },
            "yaw": {
              "type": "number",
              "format": "float"
            },
            "pitch": {
              "type": "number",
              "format": "float"
            },
            "stance": {
              "type": "integer",
              "format": "int32"
            },
            "xInternal": {
              "type": "number",
              "description": "Internally sets the value of X.  This may cause desync.",
              "format": "double"
            },
            "yInternal": {
              "type": "number",
              "description": "Internally sets the value of Y.  This may cause desync.",
              "format": "double"
            },
            "zInternal": {
              "type": "number",
              "description": "Internally sets the value of Z.  This may cause desync.",
              "format": "double"
            },
            "rollInternal": {
              "type": "number",
              "description": "Sets the roll of the Entity Position.  This may cause desync.",
              "format": "float"
            },
            "yawInternal": {
              "type": "number",
              "description": "Sets the yaw of the Entity Position.  This may cause desync.",
              "format": "float"
            },
            "pitchInternal": {
              "type": "number",
              "description": "Sets the pitch of the Entity Position.  This may cause desync.",
              "format": "float"
            },
            "stanceInternal": {
              "type": "integer",
              "description": "Sets the stance of the Entity Position.  This may cause desync.",
              "format": "int32"
            },
            "dirty": {
              "type": "boolean",
              "description": "Marks the position as dirty- requiring a refresh from the server."
            }
          }
        }
      ]
    },
    "BlockFacing": {
      "type": "object",
      "description": "Represents one of the 6 faces of a cube and all it's properties. Uses a right Handed Coordinate System. See also http://www.matrix44.net/cms/notes/opengl-3d-graphics/coordinate-systems-in-opengl\nIn short: \nNorth: Negative Z\nEast: Positive X\nSouth: Positive Z\nWest: Negative X\nUp: Positive Y\nDown: Negative Y",
      "properties": {
        "flag": {
          "type": "integer",
          "description": "The faces byte flag",
          "format": "byte"
        },
        "index": {
          "type": "integer",
          "description": "The index of the face (N=0, E=1, S=2, W=3, U=4, D=5)",
          "format": "int32"
        },
        "meshDataIndex": {
          "type": "integer",
          "description": "Index + 1",
          "format": "byte"
        },
        "horizontalAngleIndex": {
          "type": "integer",
          "description": "The angle index of the face (E = 0, N = 1, W = 2, S = 3)",
          "format": "int32"
        },
        "normali": {
          "description": "Returns a normal vector of this face",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3i"
            }
          ]
        },
        "normalf": {
          "description": "Returns a normal vector of this face",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "normalByte": {
          "type": "integer",
          "description": "Returns a normal vector of this face encoded in 6 bits/\nbit 0: 1 if south or west\nbit 1: sign bit \nbit 2: 1 if up or down\nbit 3: sign bit \nbit 4: 1 if north or south\nbit 5: sign bit ",
          "format": "byte"
        },
        "normalPacked": {
          "type": "integer",
          "description": "Normalized normal vector in format GL_INT_2_10_10_10_REV",
          "format": "int32"
        },
        "normalPackedFlags": {
          "type": "integer",
          "description": "Normalized normal vector packed into 3x4=12 bytes total and bit shifted by 15 bits, for use in meshdata flags data",
          "format": "int32"
        },
        "planeCenter": {
          "description": "Returns the center position of this face",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "code": {
          "type": "string",
          "description": "Returns the string north, east, south, west, up or down"
        },
        "isHorizontal": {
          "type": "boolean",
          "description": "True if this face is N,E,S or W"
        },
        "isVertical": {
          "type": "boolean",
          "description": "True if this face is U or D"
        },
        "isAxisNS": {
          "type": "boolean",
          "description": "True if this face is N or S"
        },
        "isAxisWE": {
          "type": "boolean",
          "description": "True if this face is N or S"
        },
        "axis": {
          "description": "The normal axis of this vector.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumAxis"
            }
          ]
        },
        "opposite": {
          "description": "Returns the opposing face",
          "oneOf": [
            {
              "$ref": "#/definitions/BlockFacing"
            }
          ]
        }
      }
    },
    "EnumAxis": {
      "type": "string",
      "description": "Represents an axis in the cartesian coordinate system",
      "x-enumNames": [
        "X",
        "Y",
        "Z"
      ],
      "enum": [
        "x",
        "y",
        "z"
      ]
    },
    "EnumEntityState": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Active",
        "Inactive",
        "Despawned"
      ],
      "enum": [
        "active",
        "inactive",
        "despawned"
      ]
    },
    "EntityDespawnReason": {
      "type": "object",
      "properties": {
        "reason": {
          "description": "The reason this entity despawned.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumDespawnReason"
            }
          ]
        },
        "damageSourceForDeath": {
          "description": "In the case of death, this was the damage source.",
          "oneOf": [
            {
              "$ref": "#/definitions/DamageSource"
            }
          ]
        }
      }
    },
    "EnumDespawnReason": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Death",
        "Combusted",
        "OutOfRange",
        "PickedUp",
        "Unload",
        "Disconnect",
        "Expire",
        "Removed"
      ],
      "enum": [
        "death",
        "combusted",
        "outOfRange",
        "pickedUp",
        "unload",
        "disconnect",
        "expire",
        "removed"
      ]
    },
    "DamageSource": {
      "type": "object",
      "properties": {
        "source": {
          "description": "The type of source the damage came from.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumDamageSource"
            }
          ]
        },
        "type": {
          "description": "The type of damage that was taken.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumDamageType"
            }
          ]
        },
        "hitPosition": {
          "description": "The hit position of where the damage occured.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "sourceEntity": {
          "description": "The source entity the damge came from. (if any)",
          "oneOf": [
            {
              "$ref": "#/definitions/Entity"
            }
          ]
        },
        "sourceBlock": {
          "description": "The source block the damage came from. (if any)",
          "oneOf": [
            {
              "$ref": "#/definitions/Block"
            }
          ]
        },
        "sourcePos": {
          "description": "the location of the damage source.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "damageTier": {
          "type": "integer",
          "description": "Tier of the weapon used to damage the entity (if any)",
          "format": "int32"
        }
      }
    },
    "EnumDamageSource": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Block",
        "Player",
        "Fall",
        "Drown",
        "Revive",
        "Void",
        "Suicide",
        "Internal",
        "Entity",
        "Explosion",
        "Machine",
        "Unknown",
        "Weather"
      ],
      "enum": [
        "block",
        "player",
        "fall",
        "drown",
        "revive",
        "void",
        "suicide",
        "internal",
        "entity",
        "explosion",
        "machine",
        "unknown",
        "weather"
      ]
    },
    "EnumDamageType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Gravity",
        "Fire",
        "BluntAttack",
        "SlashingAttack",
        "PiercingAttack",
        "Suffocation",
        "Heal",
        "Poison",
        "Hunger",
        "Crushing",
        "Frost"
      ],
      "enum": [
        "gravity",
        "fire",
        "bluntAttack",
        "slashingAttack",
        "piercingAttack",
        "suffocation",
        "heal",
        "poison",
        "hunger",
        "crushing",
        "frost"
      ]
    },
    "SyncedTreeAttribute": {
      "allOf": [
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/KeyValuePairOfStringAndIAttribute"
          }
        },
        {
          "type": "object",
          "properties": {
            "OnModified": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/TreeModifiedListener"
              }
            },
            "AllDirty": {
              "type": "boolean"
            },
            "PartialDirty": {
              "type": "boolean"
            }
          }
        }
      ]
    },
    "TreeModifiedListener": {
      "type": "object",
      "properties": {
        "listener": {
          "$ref": "#/definitions/Action"
        },
        "path": {
          "type": "string"
        }
      }
    },
    "Action": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "KeyValuePairOfStringAndIAttribute": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/IAttribute"
        }
      }
    },
    "IAttribute": {
      "type": "object",
      "description": "An attribute from an attribute tree",
      "x-abstract": true
    },
    "KeyValuePairOfStringAndEntityFloatStats": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/EntityFloatStats"
        }
      }
    },
    "EntityFloatStats": {
      "type": "object",
      "properties": {
        "valuesByKey": {
          "$ref": "#/definitions/OrderedDictionaryOfStringAndEntityStatOfSingle"
        },
        "blendType": {
          "$ref": "#/definitions/EnumStatBlendType"
        }
      }
    },
    "OrderedDictionaryOfStringAndEntityStatOfSingle": {
      "type": "object",
      "description": "Same as your normal C# Dictionary but ensures that the order in which the items are added is remembered. That way you can iterate over the dictionary with the insert order intact or set/get elements by index.\nTaken from http://www.codeproject.com/Articles/18615/OrderedDictionary-T-A-generic-implementation-of-IO\nPlease be aware that this is not a very efficient implementation, recommed use only for small sets of data.",
      "properties": {
        "InternalDictionary": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/EntityStatOfSingle"
          }
        },
        "Item": {
          "$ref": "#/definitions/EntityStatOfSingle"
        },
        "Count": {
          "type": "integer",
          "format": "int32"
        },
        "Keys": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "ValuesOrdered": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EntityStatOfSingle"
          }
        },
        "Values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EntityStatOfSingle"
          }
        },
        "IsReadOnly": {
          "type": "boolean"
        }
      }
    },
    "EntityStatOfSingle": {
      "type": "object",
      "properties": {
        "value": {
          "type": "number",
          "format": "float"
        },
        "weight": {
          "type": "number",
          "format": "float"
        },
        "persistent": {
          "type": "boolean"
        }
      }
    },
    "EnumStatBlendType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "FlatSum",
        "FlatMultiply",
        "WeightedSum",
        "WeightedOverlay"
      ],
      "enum": [
        "flatSum",
        "flatMultiply",
        "weightedSum",
        "weightedOverlay"
      ]
    },
    "EntitySidedProperties": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "behaviors": {
          "type": "array",
          "description": "The behaviors attached to this entity.",
          "items": {
            "$ref": "#/definitions/EntityBehavior"
          }
        }
      }
    },
    "EntityBehavior": {
      "type": "object",
      "description": "Defines a basic entity behavior that can be attached to entities",
      "x-abstract": true,
      "properties": {
        "entity": {
          "$ref": "#/definitions/Entity"
        }
      }
    },
    "ICoreClientAPI": {
      "type": "object",
      "description": "The core api implemented by the client. The main interface for accessing the client. Contains all sub components and some miscellaneous methods.",
      "x-abstract": true,
      "properties": {
        "linkProtocols": {
          "type": "object",
          "description": "Add your own link protocol here if you want to implement a custom protocol. E.g. image://url-to-picture",
          "additionalProperties": {
            "$ref": "#/definitions/ActionOfLinkTextComponent"
          }
        },
        "tagConverters": {
          "type": "object",
          "description": "Add your own rich text elements here. Your will need to convert a VTML tag into a RichTextComponentBase element. ",
          "additionalProperties": {
            "$ref": "#/definitions/Tag2RichTextDelegate"
          }
        },
        "settings": {
          "description": "The clients game settings as stored in the clientsettings.json",
          "oneOf": [
            {
              "$ref": "#/definitions/ISettings"
            }
          ]
        },
        "forms": {
          "description": "Platform independent ui methods and features. ",
          "oneOf": [
            {
              "$ref": "#/definitions/IXPlatformInterface"
            }
          ]
        },
        "macroManager": {
          "description": "Api to the client side macros system",
          "oneOf": [
            {
              "$ref": "#/definitions/IMacroManager"
            }
          ]
        },
        "elapsedMilliseconds": {
          "type": "integer",
          "description": "Amount of milliseconds ellapsed since client startup",
          "format": "int64"
        },
        "inWorldEllapsedMilliseconds": {
          "type": "integer",
          "description": "Amount of milliseconds ellapsed while in a running game that is not paused",
          "format": "int64"
        },
        "isShuttingDown": {
          "type": "boolean",
          "description": "True if the client is currently in the process of exiting"
        },
        "isGamePaused": {
          "type": "boolean",
          "description": "True if the game is currently paused (only available in singleplayer)"
        },
        "isSinglePlayer": {
          "type": "boolean",
          "description": "True if this is a singleplayer session"
        },
        "hideGuis": {
          "type": "boolean",
          "description": "If true, the player is in gui-less mode (through the F4 key)"
        },
        "playerReadyFired": {
          "type": "boolean",
          "description": "True if all SendPlayerNowReady() was sent, signalling the player is now ready (called by the character selector upon submit)"
        },
        "ambient": {
          "description": "API Component to control the clients ambient values",
          "oneOf": [
            {
              "$ref": "#/definitions/IAmbientManager"
            }
          ]
        },
        "event": {
          "description": "API Component for registering to various Events",
          "oneOf": [
            {
              "$ref": "#/definitions/IClientEventAPI"
            }
          ]
        },
        "render": {
          "description": "API for Rendering stuff onto the screen using OpenGL",
          "oneOf": [
            {
              "$ref": "#/definitions/IRenderAPI"
            }
          ]
        },
        "gui": {
          "description": "API for GUI Related methods",
          "oneOf": [
            {
              "$ref": "#/definitions/IGuiAPI"
            }
          ]
        },
        "input": {
          "description": "API for Mouse / Keyboard input related things",
          "oneOf": [
            {
              "$ref": "#/definitions/IInputAPI"
            }
          ]
        },
        "tesselatorManager": {
          "description": "Holds the default meshes of all blocks",
          "oneOf": [
            {
              "$ref": "#/definitions/ITesselatorManager"
            }
          ]
        },
        "tesselator": {
          "description": "API for Meshing in the Mainthread. Thread safe.",
          "oneOf": [
            {
              "$ref": "#/definitions/ITesselatorAPI"
            }
          ]
        },
        "blockTextureAtlas": {
          "description": "API for the Block Texture Atlas",
          "oneOf": [
            {
              "$ref": "#/definitions/IBlockTextureAtlasAPI"
            }
          ]
        },
        "itemTextureAtlas": {
          "description": "API for the Item Texture Atlas",
          "oneOf": [
            {
              "$ref": "#/definitions/IItemTextureAtlasAPI"
            }
          ]
        },
        "entityTextureAtlas": {
          "description": "API for the Entity Texture Atlas",
          "oneOf": [
            {
              "$ref": "#/definitions/ITextureAtlasAPI"
            }
          ]
        },
        "shader": {
          "description": "API for Rendering stuff onto the screen using OpenGL",
          "oneOf": [
            {
              "$ref": "#/definitions/IShaderAPI"
            }
          ]
        },
        "network": {
          "description": "API for doing sending/receiving network packets",
          "oneOf": [
            {
              "$ref": "#/definitions/IClientNetworkAPI"
            }
          ]
        },
        "world": {
          "description": "API for accessing anything in the game world",
          "oneOf": [
            {
              "$ref": "#/definitions/IClientWorldAccessor"
            }
          ]
        },
        "openedGuis": {
          "type": "array",
          "description": "Active GUI objects.",
          "items": {}
        },
        "currentMusicTrack": {
          "description": "Returns the currently playing music track, if any is playing",
          "oneOf": [
            {
              "$ref": "#/definitions/IMusicTrack"
            }
          ]
        }
      }
    },
    "ActionOfLinkTextComponent": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "Tag2RichTextDelegate": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object",
          "description": "A tag parser"
        }
      ]
    },
    "ISettings": {
      "type": "object",
      "description": "Setting interface for multiple settings.",
      "x-abstract": true,
      "properties": {
        "bool": {
          "description": "Setting collection for boolean values.",
          "oneOf": [
            {
              "$ref": "#/definitions/ISettingsClassOfBoolean"
            }
          ]
        },
        "int": {
          "description": "Setting collection for integer values.",
          "oneOf": [
            {
              "$ref": "#/definitions/ISettingsClassOfInteger"
            }
          ]
        },
        "float": {
          "description": "Setting collection for float values.",
          "oneOf": [
            {
              "$ref": "#/definitions/ISettingsClassOfSingle"
            }
          ]
        },
        "string": {
          "description": "Setting collection for string values.",
          "oneOf": [
            {
              "$ref": "#/definitions/ISettingsClassOfString"
            }
          ]
        },
        "strings": {
          "description": "Setting collection for string list values.",
          "oneOf": [
            {
              "$ref": "#/definitions/ISettingsClassOfListOfString"
            }
          ]
        }
      }
    },
    "ISettingsClassOfBoolean": {
      "type": "object",
      "description": "Setting interface.",
      "x-abstract": true
    },
    "ISettingsClassOfInteger": {
      "type": "object",
      "description": "Setting interface.",
      "x-abstract": true
    },
    "ISettingsClassOfSingle": {
      "type": "object",
      "description": "Setting interface.",
      "x-abstract": true
    },
    "ISettingsClassOfString": {
      "type": "object",
      "description": "Setting interface.",
      "x-abstract": true
    },
    "ISettingsClassOfListOfString": {
      "type": "object",
      "description": "Setting interface.",
      "x-abstract": true
    },
    "IXPlatformInterface": {
      "type": "object",
      "description": "The platform interface for various controls.  Used by the game to handle various properties.",
      "x-abstract": true
    },
    "IMacroManager": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "macrosByIndex": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/IMacroBase"
          }
        }
      }
    },
    "IMacroBase": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "index": {
          "type": "integer",
          "format": "int32"
        },
        "code": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "commands": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "keyCombination": {
          "$ref": "#/definitions/KeyCombination"
        },
        "iconTexture": {
          "$ref": "#/definitions/LoadedTexture"
        }
      }
    },
    "KeyCombination": {
      "type": "object",
      "description": "Mapping of a key combination",
      "properties": {
        "keyCode": {
          "type": "integer",
          "description": "The KeyCode",
          "format": "int32"
        },
        "secondKeyCode": {
          "type": [
            "integer",
            "null"
          ],
          "description": "The second key code (if it exists).",
          "format": "int32"
        },
        "ctrl": {
          "type": "boolean",
          "description": "Ctrl pressed condition."
        },
        "alt": {
          "type": "boolean",
          "description": "Alt pressed condition."
        },
        "shift": {
          "type": "boolean",
          "description": "Shift pressed condition."
        }
      }
    },
    "LoadedTexture": {
      "type": "object",
      "properties": {
        "textureId": {
          "type": "integer",
          "description": "The OpenGL Texture Id",
          "format": "int32"
        },
        "width": {
          "type": "integer",
          "description": "Width of the texture.",
          "format": "int32"
        },
        "height": {
          "type": "integer",
          "description": "Height of the texture.",
          "format": "int32"
        },
        "disposed": {
          "type": "boolean"
        },
        "ignoreUndisposed": {
          "type": "boolean",
          "description": "Set this only you really know what you're doing"
        }
      }
    },
    "IAmbientManager": {
      "type": "object",
      "description": "This is the system that manages the worlds ambient settings, such as fog color/density and clouds.\nThe ambient manager basically blends ambientmodifiers on top of each other to generate the final ambient values.\nBlending is in order how the modifiers are held in CurrentModifiers in the likes of\nfloat weight = modifier.FogMin.Weight;\nBlendedFogMin = w * modifier.FogMin.Value + (1 - w) * BlendedFogMin;",
      "x-abstract": true,
      "properties": {
        "base": {
          "description": "The base value or background ambient to overlay everything onto",
          "oneOf": [
            {
              "$ref": "#/definitions/AmbientModifier"
            }
          ]
        },
        "currentModifiers": {
          "description": "The list of modifiers that result in the blended values",
          "oneOf": [
            {
              "$ref": "#/definitions/OrderedDictionaryOfStringAndAmbientModifier"
            }
          ]
        },
        "blendedFogColor": {
          "description": "The blended fog color, calculated every frame from the list of modifiers",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec4f"
            }
          ]
        },
        "blendedAmbientColor": {
          "description": "The blended ambient color, calculated every frame from the list of modifiers",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "blendedFogDensity": {
          "type": "number",
          "description": "The blended fog density, calculated every frame from the list of modifiers",
          "format": "float"
        },
        "blendedFogBrightness": {
          "type": "number",
          "format": "float"
        },
        "blendedFlatFogDensity": {
          "type": "number",
          "description": "The blended flat fog density, calculated every frame from the list of modifiers",
          "format": "float"
        },
        "blendedFlatFogYOffset": {
          "type": "number",
          "description": "The blended flat fog y-offset, calculated every frame from the list of modifiers",
          "format": "float"
        },
        "blendedFlatFogYPosForShader": {
          "type": "number",
          "description": "BlendedFlatFogYPos + SeaLevel - MainCamera.TargetPosition.Y",
          "format": "float"
        },
        "blendedFogMin": {
          "type": "number",
          "description": "The blended fog min, calculated every frame from the list of modifiers",
          "format": "float"
        },
        "blendedCloudBrightness": {
          "type": "number",
          "description": "The blended cloud brightness, calculated every frame from the list of modifiers",
          "format": "float"
        },
        "blendedCloudDensity": {
          "type": "number",
          "description": "The blended cloud density, calculated every frame from the list of modifiers",
          "format": "float"
        },
        "blendedCloudYPos": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "AmbientModifier": {
      "type": "object",
      "properties": {
        "flatFogDensity": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "flatFogYPos": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "fogMin": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "fogDensity": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "fogColor": {
          "$ref": "#/definitions/WeightedFloatArray"
        },
        "ambientColor": {
          "$ref": "#/definitions/WeightedFloatArray"
        },
        "cloudDensity": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "cloudBrightness": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "cloudYPos": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "lerpSpeed": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "sceneBrightness": {
          "$ref": "#/definitions/WeightedFloat"
        },
        "fogBrightness": {
          "$ref": "#/definitions/WeightedFloat"
        }
      }
    },
    "WeightedFloat": {
      "allOf": [
        {
          "$ref": "#/definitions/WeightedValueOfSingle"
        },
        {
          "type": "object"
        }
      ]
    },
    "WeightedValueOfSingle": {
      "type": "object",
      "properties": {
        "value": {
          "type": "number",
          "format": "float"
        },
        "weight": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "WeightedFloatArray": {
      "allOf": [
        {
          "$ref": "#/definitions/WeightedValueOfSingleOf"
        },
        {
          "type": "object"
        }
      ]
    },
    "WeightedValueOfSingleOf": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "weight": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "OrderedDictionaryOfStringAndAmbientModifier": {
      "type": "object",
      "description": "Same as your normal C# Dictionary but ensures that the order in which the items are added is remembered. That way you can iterate over the dictionary with the insert order intact or set/get elements by index.\nTaken from http://www.codeproject.com/Articles/18615/OrderedDictionary-T-A-generic-implementation-of-IO\nPlease be aware that this is not a very efficient implementation, recommed use only for small sets of data.",
      "properties": {
        "InternalDictionary": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/AmbientModifier"
          }
        },
        "Item": {
          "$ref": "#/definitions/AmbientModifier"
        },
        "Count": {
          "type": "integer",
          "format": "int32"
        },
        "Keys": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "ValuesOrdered": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AmbientModifier"
          }
        },
        "Values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AmbientModifier"
          }
        },
        "IsReadOnly": {
          "type": "boolean"
        }
      }
    },
    "Vec4f": {
      "type": "object",
      "properties": {
        "x": {
          "type": "number",
          "format": "float"
        },
        "y": {
          "type": "number",
          "format": "float"
        },
        "z": {
          "type": "number",
          "format": "float"
        },
        "w": {
          "type": "number",
          "format": "float"
        },
        "r": {
          "type": "number",
          "description": "Synonum for X",
          "format": "float"
        },
        "g": {
          "type": "number",
          "description": "Synonum for Y",
          "format": "float"
        },
        "b": {
          "type": "number",
          "description": "Synonum for Z",
          "format": "float"
        },
        "a": {
          "type": "number",
          "description": "Synonum for W",
          "format": "float"
        },
        "xyz": {
          "$ref": "#/definitions/Vec3f"
        }
      }
    },
    "IClientEventAPI": {
      "type": "object",
      "description": "Contains some client specific events you can hook into",
      "x-abstract": true
    },
    "IRenderAPI": {
      "type": "object",
      "description": "The main api component to assist you in rendering pretty stuff onto the screen",
      "x-abstract": true,
      "properties": {
        "scissorStack": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElementBounds"
          }
        },
        "textureSize": {
          "type": "integer",
          "format": "int32"
        },
        "defaultFrustumCuller": {
          "$ref": "#/definitions/FrustumCulling"
        },
        "frameBuffers": {
          "type": "array",
          "description": "List of all loaded frame buffers. To get the god rays frame buffer for exampple, do Framebuffers[(int)EnumFrameBuffer.GodRays]",
          "items": {
            "$ref": "#/definitions/FrameBufferRef"
          }
        },
        "shaderUniforms": {
          "description": "A number of default shader uniforms",
          "oneOf": [
            {
              "$ref": "#/definitions/DefaultShaderUniforms"
            }
          ]
        },
        "cameraOffset": {
          "description": "Can be used to offset the position of the player camera",
          "oneOf": [
            {
              "$ref": "#/definitions/ModelTransform"
            }
          ]
        },
        "currentRenderStage": {
          "description": "The render stage the engine is currently at",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumRenderStage"
            }
          ]
        },
        "perspectiveViewMat": {
          "type": "array",
          "description": "The default view matrix used during perspective rendering. Is refreshed before EnumRenderStage.Opaque. Useful for doing projections in the Ortho stage via MatrixToolsd.Project()",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "perspectiveProjectionMat": {
          "type": "array",
          "description": "The default projection matrix used during perspective rendering. Is refreshed before EnumRenderStage.Opaque. Useful for doing projections in the Ortho stage via MatrixToolsd.Project()",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "decorativeFontName": {
          "type": "string",
          "description": "The name of the font used during this render (if it exists).",
          "x-deprecated": true,
          "x-deprecatedMessage": "Please use ElementGeometrics.DecorativeFontName instead"
        },
        "standardFontName": {
          "type": "string",
          "description": "The standard font used during this render (if it exists).",
          "x-deprecated": true,
          "x-deprecatedMessage": "Please use ElementGeometrics.StandardFontName instead."
        },
        "frameWidth": {
          "type": "integer",
          "description": "Width of the primary render framebuffer",
          "format": "int32"
        },
        "frameHeight": {
          "type": "integer",
          "description": "Height of the primary render framebuffer",
          "format": "int32"
        },
        "cameraType": {
          "description": "The camera type.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumCameraMode"
            }
          ]
        },
        "mvMatrix": {
          "description": "The current modelview matrix stack",
          "oneOf": [
            {
              "$ref": "#/definitions/StackMatrix4"
            }
          ]
        },
        "pMatrix": {
          "description": "The current projection matrix stack",
          "oneOf": [
            {
              "$ref": "#/definitions/StackMatrix4"
            }
          ]
        },
        "lineWidth": {
          "type": "number",
          "format": "float"
        },
        "currentModelviewMatrix": {
          "type": "array",
          "description": "The current top most matrix in the model view matrix stack. ",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "cameraMatrixOrigin": {
          "type": "array",
          "description": "Player camera matrix with player positioned at 0,0,0.\nYou can use this matrix instead of CurrentModelviewMatrix for high precision rendering.",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "cameraMatrixOriginf": {
          "type": "array",
          "description": "Player camera matrix with player positioned at 0,0,0.\nYou can use this matrix instead of CurrentModelviewMatrix for high precision rendering.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "currentProjectionMatrix": {
          "type": "array",
          "description": "The current top most matrix in the projection matrix stack",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "currentShadowProjectionMatrix": {
          "type": "array",
          "description": "The current projection matrix for shadow rendering (renders the scene from the viewpoint of the sun)",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "standardShader": {
          "description": "Gives you a reference to the \"standard\" shader, a general purpose shader for normal shading work",
          "oneOf": [
            {
              "$ref": "#/definitions/IStandardShaderProgram"
            }
          ]
        },
        "currentActiveShader": {
          "description": "Gives you a reference to the currently active shader, or null if none is active right now",
          "oneOf": [
            {
              "$ref": "#/definitions/IShaderProgram"
            }
          ]
        },
        "ambientColor": {
          "description": "The current ambient color (e.g. will return a blue tint when player is under water)",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "fogColor": {
          "description": "The current fog color (e.g. will return a blue tint when player is under water)",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec4f"
            }
          ]
        },
        "fogMin": {
          "type": "number",
          "description": "Current minimum fog value ",
          "format": "float"
        },
        "fogDensity": {
          "type": "number",
          "description": "Density of the current fog. Fog is calculated as followed in the shaders: clamp(fogMin + 1 - 1 / exp(gl_FragDepth * fogDensity), 0, 1)",
          "format": "float"
        }
      }
    },
    "ElementBounds": {
      "type": "object",
      "description": "Box sizing model comparable to the box sizing model of cascading style sheets using \"position:relative;\"\nEach element has a position, size, padding and margin\nPadding is counted towards the size of the box, whereas margin is not",
      "properties": {
        "parentBounds": {
          "$ref": "#/definitions/ElementBounds"
        },
        "childBounds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElementBounds"
          }
        },
        "code": {
          "type": "string",
          "description": "For debugging purposes only"
        },
        "alignment": {
          "$ref": "#/definitions/EnumDialogArea"
        },
        "verticalSizing": {
          "$ref": "#/definitions/ElementSizing"
        },
        "horizontalSizing": {
          "$ref": "#/definitions/ElementSizing"
        },
        "percentPaddingX": {
          "type": "number",
          "format": "double"
        },
        "percentPaddingY": {
          "type": "number",
          "format": "double"
        },
        "percentX": {
          "type": "number",
          "format": "double"
        },
        "percentY": {
          "type": "number",
          "format": "double"
        },
        "percentWidth": {
          "type": "number",
          "format": "double"
        },
        "percentHeight": {
          "type": "number",
          "format": "double"
        },
        "fixedMarginX": {
          "type": "number",
          "format": "double"
        },
        "fixedMarginY": {
          "type": "number",
          "format": "double"
        },
        "fixedPaddingX": {
          "type": "number",
          "format": "double"
        },
        "fixedPaddingY": {
          "type": "number",
          "format": "double"
        },
        "fixedX": {
          "type": "number",
          "format": "double"
        },
        "fixedY": {
          "type": "number",
          "format": "double"
        },
        "fixedWidth": {
          "type": "number",
          "format": "double"
        },
        "fixedHeight": {
          "type": "number",
          "format": "double"
        },
        "fixedOffsetX": {
          "type": "number",
          "format": "double"
        },
        "fixedOffsetY": {
          "type": "number",
          "format": "double"
        },
        "absPaddingX": {
          "type": "number",
          "format": "double"
        },
        "absPaddingY": {
          "type": "number",
          "format": "double"
        },
        "absMarginX": {
          "type": "number",
          "format": "double"
        },
        "absMarginY": {
          "type": "number",
          "format": "double"
        },
        "absOffsetX": {
          "type": "number",
          "format": "double"
        },
        "absOffsetY": {
          "type": "number",
          "format": "double"
        },
        "absFixedX": {
          "type": "number",
          "format": "double"
        },
        "absFixedY": {
          "type": "number",
          "format": "double"
        },
        "absInnerWidth": {
          "type": "number",
          "format": "double"
        },
        "absInnerHeight": {
          "type": "number",
          "format": "double"
        },
        "name": {
          "type": "string"
        },
        "initialized": {
          "type": "boolean"
        },
        "isDrawingSurface": {
          "type": "boolean"
        },
        "renderOffsetX": {
          "type": "number",
          "format": "double"
        },
        "renderOffsetY": {
          "type": "number",
          "format": "double"
        },
        "bothSizing": {
          "description": "Set the vertical and horizontal sizing, see also ElementSizing. Setting this is equal to calling ElementSizing)",
          "oneOf": [
            {
              "$ref": "#/definitions/ElementSizing"
            }
          ]
        },
        "requiresRecalculation": {
          "type": "boolean"
        },
        "relX": {
          "type": "number",
          "description": "Position relative to it's parent element plus margin",
          "format": "double"
        },
        "relY": {
          "type": "number",
          "format": "double"
        },
        "absX": {
          "type": "number",
          "description": "Absolute position of the element plus margin. Same as renderX but without padding",
          "format": "double"
        },
        "absY": {
          "type": "number",
          "format": "double"
        },
        "outerWidth": {
          "type": "number",
          "description": "Width including padding",
          "format": "double"
        },
        "outerHeight": {
          "type": "number",
          "description": "Height including padding",
          "format": "double"
        },
        "outerWidthInt": {
          "type": "integer",
          "format": "int32"
        },
        "outerHeightInt": {
          "type": "integer",
          "format": "int32"
        },
        "innerWidth": {
          "type": "number",
          "format": "double"
        },
        "innerHeight": {
          "type": "number",
          "format": "double"
        },
        "drawX": {
          "type": "number",
          "description": "Position where the element has to be drawn. This is a position relative to it's parent element plus margin plus padding. ",
          "format": "double"
        },
        "drawY": {
          "type": "number",
          "format": "double"
        },
        "bgDrawX": {
          "type": "number",
          "description": "Position where the background has to be drawn, this encompasses the elements padding",
          "format": "double"
        },
        "bgDrawY": {
          "type": "number",
          "format": "double"
        },
        "renderX": {
          "type": "number",
          "format": "double"
        },
        "renderY": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "EnumDialogArea": {
      "type": "string",
      "description": "First word = X Alignment (left, center, right or fixed)\nSecond word = Y Alignment (top, middle, bottom or fixed)",
      "x-enumNames": [
        "None",
        "LeftTop",
        "LeftMiddle",
        "LeftBottom",
        "LeftFixed",
        "CenterTop",
        "CenterMiddle",
        "CenterBottom",
        "CenterFixed",
        "RightTop",
        "RightMiddle",
        "RightBottom",
        "RightFixed",
        "FixedTop",
        "FixedMiddle",
        "FixedBottom",
        "TextBaselineOffset"
      ],
      "enum": [
        "none",
        "leftTop",
        "leftMiddle",
        "leftBottom",
        "leftFixed",
        "centerTop",
        "centerMiddle",
        "centerBottom",
        "centerFixed",
        "rightTop",
        "rightMiddle",
        "rightBottom",
        "rightFixed",
        "fixedTop",
        "fixedMiddle",
        "fixedBottom",
        "textBaselineOffset"
      ]
    },
    "ElementSizing": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Fixed",
        "Percentual",
        "FitToChildren",
        "PercentualSubstractFixed"
      ],
      "enum": [
        "fixed",
        "percentual",
        "fitToChildren",
        "percentualSubstractFixed"
      ]
    },
    "FrustumCulling": {
      "type": "object",
      "properties": {
        "viewDistanceSq": {
          "type": "integer",
          "format": "int32"
        },
        "lod0BiasSq": {
          "type": "number",
          "format": "float"
        },
        "lod2BiasSq": {
          "type": "number",
          "description": "If distance squared is above this fraction of ViewDistanceSq, switch to LOD2.  Default value corresponds to distances beyond around 67% of the player's view distance.   At default, approximately 55% of the total rendered chunks will use LOD2.",
          "format": "double"
        },
        "shadowRangeX": {
          "type": "number",
          "format": "double"
        },
        "shadowRangeZ": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "FrameBufferRef": {
      "type": "object",
      "properties": {
        "fbAttrs": {
          "$ref": "#/definitions/FramebufferAttrs"
        },
        "fboId": {
          "type": "integer",
          "format": "int32"
        },
        "depthTextureId": {
          "type": "integer",
          "format": "int32"
        },
        "colorTextureIds": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "width": {
          "type": "integer",
          "format": "int32"
        },
        "height": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "FramebufferAttrs": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "attachments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FramebufferAttrsAttachment"
          }
        },
        "width": {
          "type": "integer",
          "format": "int32"
        },
        "height": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "FramebufferAttrsAttachment": {
      "type": "object",
      "properties": {
        "texture": {
          "$ref": "#/definitions/RawTexture"
        },
        "attachmentType": {
          "$ref": "#/definitions/EnumFramebufferAttachment"
        }
      }
    },
    "RawTexture": {
      "type": "object",
      "properties": {
        "minFilter": {
          "$ref": "#/definitions/EnumTextureFilter"
        },
        "magFilter": {
          "$ref": "#/definitions/EnumTextureFilter"
        },
        "wrapS": {
          "$ref": "#/definitions/EnumTextureWrap"
        },
        "wrapT": {
          "$ref": "#/definitions/EnumTextureWrap"
        },
        "pixelInternalFormat": {
          "$ref": "#/definitions/EnumTextureInternalFormat"
        },
        "pixelFormat": {
          "$ref": "#/definitions/EnumTexturePixelFormat"
        },
        "width": {
          "type": "integer",
          "format": "int32"
        },
        "height": {
          "type": "integer",
          "format": "int32"
        },
        "textureId": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "EnumTextureFilter": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Nearest",
        "Linear"
      ],
      "enum": [
        "nearest",
        "linear"
      ]
    },
    "EnumTextureWrap": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Repeat",
        "ClampToEdge"
      ],
      "enum": [
        "repeat",
        "clampToEdge"
      ]
    },
    "EnumTextureInternalFormat": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Rgba8",
        "DepthComponent32",
        "R16f",
        "Rgba16f"
      ],
      "enum": [
        "rgba8",
        "depthComponent32",
        "r16f",
        "rgba16f"
      ]
    },
    "EnumTexturePixelFormat": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "DepthComponent",
        "Red",
        "Rgba"
      ],
      "enum": [
        "depthComponent",
        "red",
        "rgba"
      ]
    },
    "EnumFramebufferAttachment": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "ColorAttachment0",
        "ColorAttachment1",
        "ColorAttachment2",
        "ColorAttachment3",
        "ColorAttachment4",
        "DepthAttachment"
      ],
      "enum": [
        "colorAttachment0",
        "colorAttachment1",
        "colorAttachment2",
        "colorAttachment3",
        "colorAttachment4",
        "depthAttachment"
      ]
    },
    "DefaultShaderUniforms": {
      "type": "object",
      "properties": {
        "zNear": {
          "type": "number",
          "description": "The currently configured z-near plane",
          "format": "float"
        },
        "zFar": {
          "type": "number",
          "description": "The currently configured z-far plane",
          "format": "float"
        },
        "dropShadowIntensity": {
          "type": "number",
          "format": "float"
        },
        "shadowRangeNear": {
          "type": "number",
          "format": "float"
        },
        "shadowRangeFar": {
          "type": "number",
          "format": "float"
        },
        "shadowZExtendNear": {
          "type": "number",
          "format": "float"
        },
        "shadowZExtendFar": {
          "type": "number",
          "format": "float"
        },
        "toShadowMapSpaceMatrixFar": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "toShadowMapSpaceMatrixNear": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "pointLightsCount": {
          "type": "integer",
          "format": "int32"
        },
        "pointLights3": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "pointLightColors3": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "sunPositionScreen": {
          "$ref": "#/definitions/Vec3f"
        },
        "sunPosition3D": {
          "$ref": "#/definitions/Vec3f"
        },
        "lightPosition3D": {
          "$ref": "#/definitions/Vec3f"
        },
        "playerViewVector": {
          "$ref": "#/definitions/Vec3f"
        },
        "damageVignetting": {
          "type": "number",
          "format": "float"
        },
        "frostVignetting": {
          "type": "number",
          "format": "float"
        },
        "extraSepia": {
          "type": "number",
          "format": "float"
        },
        "extraBloom": {
          "type": "number",
          "format": "float"
        },
        "flagFogDensity": {
          "type": "number",
          "format": "float"
        },
        "flatFogStartYPos": {
          "type": "number",
          "format": "float"
        },
        "dusk": {
          "type": "integer",
          "format": "int32"
        },
        "waterStillCounter": {
          "type": "number",
          "format": "float"
        },
        "waterFlowCounter": {
          "type": "number",
          "format": "float"
        },
        "waterWaveCounter": {
          "type": "number",
          "format": "float"
        },
        "windWaveCounter": {
          "type": "number",
          "format": "float"
        },
        "windWaveCounterHighFreq": {
          "type": "number",
          "format": "float"
        },
        "glitchStrength": {
          "type": "number",
          "format": "float"
        },
        "windSpeed": {
          "type": "number",
          "format": "float"
        },
        "windWaveIntensity": {
          "type": "number",
          "format": "float"
        },
        "fogWaveCounter": {
          "type": "number",
          "format": "float"
        },
        "globalWorldWarp": {
          "type": "number",
          "format": "float"
        },
        "seaLevel": {
          "type": "number",
          "format": "float"
        },
        "sunsetMod": {
          "type": "number",
          "format": "float"
        },
        "sunLightTextureId": {
          "type": "integer",
          "format": "int32"
        },
        "glowTextureId": {
          "type": "integer",
          "format": "int32"
        },
        "skyTextureId": {
          "type": "integer",
          "format": "int32"
        },
        "ditherSeed": {
          "type": "integer",
          "format": "int32"
        },
        "frameWidth": {
          "type": "integer",
          "format": "int32"
        },
        "playerToSealevelOffset": {
          "type": "number",
          "format": "float"
        },
        "colorMapRects4": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "seasonRel": {
          "type": "number",
          "format": "float"
        },
        "blockAtlasHeight": {
          "type": "number",
          "format": "float"
        },
        "seasonTemperature": {
          "type": "number",
          "format": "float"
        },
        "sunSpecularIntensity": {
          "type": "number",
          "format": "float"
        },
        "playerPos": {
          "$ref": "#/definitions/Vec3f"
        },
        "playerReferencePos": {
          "$ref": "#/definitions/Vec3d"
        }
      }
    },
    "EnumRenderStage": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Before",
        "Opaque",
        "OIT",
        "AfterOIT",
        "ShadowFar",
        "ShadowFarDone",
        "ShadowNear",
        "ShadowNearDone",
        "AfterPostProcessing",
        "Ortho",
        "AfterFinalComposition",
        "Done"
      ],
      "enum": [
        "before",
        "opaque",
        "oit",
        "afterOIT",
        "shadowFar",
        "shadowFarDone",
        "shadowNear",
        "shadowNearDone",
        "afterPostProcessing",
        "ortho",
        "afterFinalComposition",
        "done"
      ]
    },
    "EnumCameraMode": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "FirstPerson",
        "ThirdPerson",
        "Overhead"
      ],
      "enum": [
        "firstPerson",
        "thirdPerson",
        "overhead"
      ]
    },
    "StackMatrix4": {
      "type": "object",
      "properties": {
        "top": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "IStandardShaderProgram": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "tex2D": {
          "type": "integer",
          "description": "The texture 2D for this mesh.",
          "format": "int32"
        },
        "shadowMapNear2D": {
          "type": "integer",
          "description": "The shadowmap ID for nearby shadows.",
          "format": "int32"
        },
        "shadowMapFar2D": {
          "type": "integer",
          "description": "The shadowmap ID for far away shadows.",
          "format": "int32"
        },
        "normalShaded": {
          "type": "integer",
          "format": "int32"
        },
        "zNear": {
          "type": "number",
          "description": "The Near plane distance.",
          "format": "float"
        },
        "zFar": {
          "type": "number",
          "description": "The far plane distance.",
          "format": "float"
        },
        "alphaTest": {
          "type": "number",
          "description": "The shader will discard things below this threshold.",
          "format": "float"
        },
        "extraZOffset": {
          "type": "number",
          "format": "float"
        },
        "extraGodray": {
          "type": "number",
          "format": "float"
        },
        "rgbaAmbientIn": {
          "description": "The color of the ambient light source.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "rgbaLightIn": {
          "description": "The color of the general light.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec4f"
            }
          ]
        },
        "rgbaGlowIn": {
          "description": "The color of the glow light.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec4f"
            }
          ]
        },
        "rgbaFogIn": {
          "description": "The color of the fog.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec4f"
            }
          ]
        },
        "rgbaTint": {
          "description": "The color of the tint.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec4f"
            }
          ]
        },
        "fogMinIn": {
          "type": "number",
          "description": "The minimum distance for fog.",
          "format": "float"
        },
        "fogDensityIn": {
          "type": "number",
          "description": "The density level of the fog.",
          "format": "float"
        },
        "projectionMatrix": {
          "type": "array",
          "description": "The projection matrix.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "modelMatrix": {
          "type": "array",
          "description": "The model Matrix.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "viewMatrix": {
          "type": "array",
          "description": "The view matrix.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "extraGlow": {
          "type": "integer",
          "format": "int32"
        },
        "toShadowMapSpaceMatrixFar": {
          "type": "array",
          "description": "The matrix for converting the vertex position from world space to far shadow space as supplied by IRenderAPI.CurrentShadowProjectionMatrix.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "toShadowMapSpaceMatrixNear": {
          "type": "array",
          "description": "The matrix for converting the vertex position from world space to near shadow space as supplied by IRenderAPI.CurrentShadowProjectionMatrix.",
          "items": {
            "type": "number",
            "format": "float"
          }
        },
        "waterWaveCounter": {
          "type": "number",
          "description": "Required for water waving meshes.  Supplied the water counter as supplied as IRenderAPI.WaterWaveCounter.",
          "format": "float"
        },
        "dontWarpVertices": {
          "type": "integer",
          "description": "The position of the player.",
          "format": "int32"
        },
        "addRenderFlags": {
          "type": "integer",
          "format": "int32"
        },
        "tex2dOverlay2D": {
          "type": "integer",
          "format": "int32"
        },
        "overlayOpacity": {
          "type": "number",
          "format": "float"
        },
        "ssaoAttn": {
          "type": "number",
          "format": "float"
        },
        "overlayTextureSize": {
          "$ref": "#/definitions/Vec2f"
        },
        "baseTextureSize": {
          "$ref": "#/definitions/Vec2f"
        },
        "baseUvOrigin": {
          "$ref": "#/definitions/Vec2f"
        }
      }
    },
    "IShaderProgram": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "passId": {
          "type": "integer",
          "description": "A uniqe shader pass number assigned to each shader program",
          "format": "int32"
        },
        "passName": {
          "type": "string",
          "description": "The name it was registered with. If you want to load this shader from a file, make sure the use the filename here"
        },
        "clampTexturesToEdge": {
          "type": "boolean",
          "description": "If true, it well configure the textures to clamp to the edge (CLAMP_TO_EDGE). Requires the textureid to be defined using SetTextureIds"
        },
        "vertexShader": {
          "description": "The vertex shader of this shader program",
          "oneOf": [
            {
              "$ref": "#/definitions/IShader"
            }
          ]
        },
        "fragmentShader": {
          "description": "The fragment shader of this shader program",
          "oneOf": [
            {
              "$ref": "#/definitions/IShader"
            }
          ]
        },
        "geometryShader": {
          "description": "The geometry shader of this shader program",
          "oneOf": [
            {
              "$ref": "#/definitions/IShader"
            }
          ]
        },
        "disposed": {
          "type": "boolean",
          "description": "True if this shader has been disposed"
        }
      }
    },
    "IShader": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "type": {
          "$ref": "#/definitions/EnumShaderType"
        },
        "prefixCode": {
          "type": "string",
          "description": "If set, the shader registry will attach this bit of code to the beginning of the fragment shader file. Useful for setting stuff at runtime when using file shaders, e.g. via #define"
        },
        "code": {
          "type": "string",
          "description": "Source code of the shader"
        }
      }
    },
    "EnumShaderType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "FragmentShader",
        "VertexShader",
        "GeometryShader",
        "GeometryShaderExt",
        "TessEvaluationShader",
        "TessControlShader",
        "ComputeShader"
      ],
      "enum": [
        "fragmentShader",
        "vertexShader",
        "geometryShaderExt",
        "tessEvaluationShader",
        "tessControlShader",
        "computeShader"
      ]
    },
    "IGuiAPI": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "quadMeshRef": {
          "description": "Just a default gpu-uploaded quad for 2d texture rendering, for your convenience",
          "oneOf": [
            {
              "$ref": "#/definitions/MeshRef"
            }
          ]
        },
        "loadedGuis": {
          "type": "array",
          "description": "List of all registered guis",
          "items": {
            "$ref": "#/definitions/GuiDialog"
          }
        },
        "openedGuis": {
          "type": "array",
          "description": "List of all currently opened guis",
          "items": {
            "$ref": "#/definitions/GuiDialog"
          }
        },
        "textTexture": {
          "description": "A utility class that does text texture generation for you",
          "oneOf": [
            {
              "$ref": "#/definitions/TextTextureUtil"
            }
          ]
        },
        "text": {
          "description": "A utlity class that helps draw text",
          "oneOf": [
            {
              "$ref": "#/definitions/TextDrawUtil"
            }
          ]
        },
        "icons": {
          "description": "A utility class that contains a bunch of hardcoded icons",
          "oneOf": [
            {
              "$ref": "#/definitions/IconUtil"
            }
          ]
        },
        "windowBounds": {
          "description": "Returns a ElementBounds that is always the size of the game window",
          "oneOf": [
            {
              "$ref": "#/definitions/ElementBounds"
            }
          ]
        }
      }
    },
    "MeshRef": {
      "type": "object",
      "description": "A reference to a mesh that's been uploaded onto the graphics card (i.e. that has been placed in an OpenGL VAO). This reference can be used for rendering it.",
      "properties": {
        "disposed": {
          "type": "boolean",
          "description": "Am I disposed?"
        }
      }
    },
    "GuiDialog": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "composers": {
          "type": "array",
          "description": "The Instance of Dialogue Composer for this GUIDialogue.",
          "items": {}
        },
        "ignoreNextKeyPress": {
          "type": "boolean"
        },
        "mouseOverCursor": {
          "type": "string"
        },
        "singleComposer": {
          "description": "A single composer for this GUIDialogue.",
          "oneOf": [
            {
              "$ref": "#/definitions/GuiComposer"
            }
          ]
        },
        "debugName": {
          "type": "string",
          "description": "Debug name.  For debugging purposes."
        },
        "zSize": {
          "type": "number",
          "description": "The amount of depth required for this dialog. Default is 150. Required for correct z-ordering of dialogs.",
          "format": "float"
        },
        "focused": {
          "type": "boolean",
          "description": "Is the dialogue currently in focus?"
        },
        "focusable": {
          "type": "boolean",
          "description": "Can this dialog be focused?"
        },
        "dialogType": {
          "description": "Is this dialogue a dialogue or a HUD object?",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumDialogType"
            }
          ]
        },
        "drawOrder": {
          "type": "number",
          "description": "0 = draw first, 1 = draw last. Used to enforce tooltips and held itemstack always drawn last to be visible.",
          "format": "double"
        },
        "inputOrder": {
          "type": "number",
          "format": "double"
        },
        "unregisterOnClose": {
          "type": "boolean",
          "description": "Should this dialogue de-register itself once it's closed? (Defaults to no)"
        },
        "prefersUngrabbedMouse": {
          "type": "boolean",
          "description": "Gets whether it is preferred for the mouse to be not grabbed while this dialog is opened.\nIf true (default), the Alt button needs to be held to manually grab the mouse."
        },
        "disableMouseGrab": {
          "type": "boolean",
          "description": "Gets whether ability to grab the mouse cursor is disabled while\nthis dialog is opened. For example, the escape menu. (Default: false)"
        }
      }
    },
    "GuiComposer": {
      "type": "object",
      "description": "Composes a dialog which are made from a set of elements\nThe composed dialog is cached, so to recompose you have to Recompose All elements or instantiate a new composer with doCache set to false\nThe caching allows the dialog using the composer to not worry about performance and just call compose whenever it has to display a new composed dialog\nYou add components by chaining the functions of the composer together for building the result.",
      "properties": {
        "onFocusChanged": {
          "$ref": "#/definitions/ActionOfBoolean"
        },
        "api": {
          "$ref": "#/definitions/ICoreClientAPI"
        },
        "zDepth": {
          "type": "number",
          "format": "float"
        },
        "color": {
          "$ref": "#/definitions/Vec4f"
        },
        "tabbable": {
          "type": "boolean",
          "description": "Whether or not the Tab-Key down event should be used and consumed to cycle-focus individual gui elements"
        },
        "mouseOverCursor": {
          "type": "string"
        },
        "currentElementKey": {
          "type": "integer",
          "description": "A unique number assigned to each element",
          "format": "int32"
        },
        "bounds": {
          "$ref": "#/definitions/ElementBounds"
        },
        "currentTabIndexElement": {
          "description": "Gets the currently tabbed index element, if there is one currently focused.",
          "oneOf": [
            {
              "$ref": "#/definitions/GuiElement"
            }
          ]
        },
        "firstTabbableElement": {
          "$ref": "#/definitions/GuiElement"
        },
        "maxTabIndex": {
          "type": "integer",
          "description": "Gets the maximum tab index of the components.",
          "format": "int32"
        }
      }
    },
    "ActionOfBoolean": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "GuiElement": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "bounds": {
          "description": "The bounds of the element.",
          "oneOf": [
            {
              "$ref": "#/definitions/ElementBounds"
            }
          ]
        },
        "tabIndex": {
          "type": "integer",
          "description": "The tab index of the element.",
          "format": "int32"
        },
        "insideClipBounds": {
          "description": "If the element is inside a clip or not.",
          "oneOf": [
            {
              "$ref": "#/definitions/ElementBounds"
            }
          ]
        },
        "renderAsPremultipliedAlpha": {
          "type": "boolean"
        },
        "hasFocus": {
          "type": "boolean",
          "description": "Whether or not the element has focus or not."
        },
        "drawOrder": {
          "type": "number",
          "description": "0 = draw first, 1 = draw last. Only for interactive elements.",
          "format": "double"
        },
        "focusable": {
          "type": "boolean",
          "description": "Whether or not the element can be focused."
        },
        "scale": {
          "type": "number",
          "description": "The scale of the element.",
          "format": "double"
        },
        "mouseOverCursor": {
          "type": "string"
        }
      }
    },
    "EnumDialogType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "Dialog",
        "HUD"
      ],
      "enum": [
        "dialog",
        "hud"
      ]
    },
    "TextTextureUtil": {
      "type": "object"
    },
    "TextDrawUtil": {
      "type": "object"
    },
    "IconUtil": {
      "type": "object"
    },
    "IInputAPI": {
      "type": "object",
      "description": "This interface manages the inputs of the player and is used mostly on the client side.  ",
      "x-abstract": true,
      "properties": {
        "keyboardKeyStateRaw": {
          "type": "array",
          "description": "The current keyboard key states, use the GlKeys enum to get the index of an array key.",
          "items": {
            "type": "boolean"
          }
        },
        "keyboardKeyState": {
          "type": "array",
          "description": "The current keyboard key states that were not handled by a dialog or other client systems (exception: hotkeys), use the GlKeys enum to get the array index of a key.",
          "items": {
            "type": "boolean"
          }
        },
        "mouseButton": {
          "description": "The current mouse button state",
          "oneOf": [
            {
              "$ref": "#/definitions/MouseButtonState"
            }
          ]
        },
        "inWorldMouseButton": {
          "description": "The current mouse button state outside of dialogs / clicked inside the game world",
          "oneOf": [
            {
              "$ref": "#/definitions/MouseButtonState"
            }
          ]
        },
        "mouseX": {
          "type": "integer",
          "description": "The current x-position of the mouse, relative to the upper left corner of the game window",
          "format": "int32"
        },
        "mouseY": {
          "type": "integer",
          "description": "The current y-position of the mouse, relative to the upper left corner of the game window",
          "format": "int32"
        },
        "mouseYaw": {
          "type": "number",
          "description": "When controlling the camera, this is the camera yaw determined by the game engine",
          "format": "float"
        },
        "mousePitch": {
          "type": "number",
          "description": "When controlling the camera, this is the camera pitch determined by the game engine",
          "format": "float"
        },
        "mouseWorldInteractAnyway": {
          "type": "boolean",
          "description": "Gives the player the ability to still interact with the world even if a gui dialog is opened"
        },
        "mouseGrabbed": {
          "type": "boolean",
          "description": "True if the mouse cursor is currently grabbed and not visible.\n(Such as while controlling the character's view in first person.)"
        },
        "hotKeys": {
          "description": "Returns a list of all currently registered hotkeys.",
          "oneOf": [
            {
              "$ref": "#/definitions/OrderedDictionaryOfStringAndHotKey"
            }
          ]
        }
      }
    },
    "MouseButtonState": {
      "type": "object",
      "properties": {
        "left": {
          "type": "boolean"
        },
        "middle": {
          "type": "boolean"
        },
        "right": {
          "type": "boolean"
        }
      }
    },
    "OrderedDictionaryOfStringAndHotKey": {
      "type": "object",
      "description": "Same as your normal C# Dictionary but ensures that the order in which the items are added is remembered. That way you can iterate over the dictionary with the insert order intact or set/get elements by index.\nTaken from http://www.codeproject.com/Articles/18615/OrderedDictionary-T-A-generic-implementation-of-IO\nPlease be aware that this is not a very efficient implementation, recommed use only for small sets of data.",
      "properties": {
        "InternalDictionary": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HotKey"
          }
        },
        "Item": {
          "$ref": "#/definitions/HotKey"
        },
        "Count": {
          "type": "integer",
          "format": "int32"
        },
        "Keys": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "ValuesOrdered": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HotKey"
          }
        },
        "Values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HotKey"
          }
        },
        "IsReadOnly": {
          "type": "boolean"
        }
      }
    },
    "HotKey": {
      "type": "object",
      "properties": {
        "isGlobalHotkey": {
          "type": "boolean",
          "description": "For global hotkeys that shall not be blocked by anything (e.g. F11 for fullscreen, F12 for screenshot)"
        },
        "isIngameHotkey": {
          "type": "boolean",
          "description": "For hotkeys that only available during a game session. When the game session ends, the handler to this hotkey is removed (or we have a dead reference to runninggame)"
        },
        "currentMapping": {
          "description": "The current key combination for this hotkey",
          "oneOf": [
            {
              "$ref": "#/definitions/KeyCombination"
            }
          ]
        },
        "defaultMapping": {
          "description": "The default key combination for this hotkey",
          "oneOf": [
            {
              "$ref": "#/definitions/KeyCombination"
            }
          ]
        },
        "code": {
          "type": "string",
          "description": "The code of the Hotkey."
        },
        "name": {
          "type": "string",
          "description": "The name of the Hotkey"
        },
        "keyCombinationType": {
          "description": "The type of the key combination.  This defaults to HotkeyType.CharacterControls.",
          "oneOf": [
            {
              "$ref": "#/definitions/HotkeyType"
            }
          ]
        },
        "handler": {
          "description": "This is the action that happens when the hotkey is used.",
          "oneOf": [
            {
              "$ref": "#/definitions/ActionConsumableOfKeyCombination"
            }
          ]
        }
      }
    },
    "HotkeyType": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "GUIOrOtherControls",
        "CharacterControls",
        "CreativeTool",
        "CreativeOrSpectatorTool",
        "DevTool"
      ],
      "enum": [
        "guiOrOtherControls",
        "characterControls",
        "creativeTool",
        "creativeOrSpectatorTool",
        "devTool"
      ]
    },
    "ActionConsumableOfKeyCombination": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object",
          "description": "Return true if the action/event should be \"consumed\" (e.g. mark a mouse click as handled)"
        }
      ]
    },
    "ITesselatorManager": {
      "type": "object",
      "description": "Manager interface for Tesselators.",
      "x-abstract": true
    },
    "ITesselatorAPI": {
      "type": "object",
      "description": "Interface that allows custom model model meshing for items, blocks and entities\nTexturing crash course:\n1. Block, Item and Entity textures are loaded from json files in the form of a CompositeTexture instance\n2. After connecting to a game server, the client inserts all of these textures into their type-respective texture atlasses\n3. After insertion a \"texture sub-id\" is left behind in the CompositeTexture.Baked Property\n4. You can now find the position of the texture inside the atlas through the Block/Item/Entity-TextureAtlasPositions arrays (teturesubid is the array key)\n\nShape Tesselation crash course:\n1. Block and Item shapes are loaded from json files in the form of a CompositeShape instance\n2. A CompositeShape instance hold some block/item specific information as well as an identifier to a Shape instance\n4. After connecting to a game server, the client loads all shapes from the shape folder then finds each blocks/items shape by its shape identifier \n5. Result is a MeshData instance that holds all vertices, UV coords, colors and etc. for each block\n6. That meshdata instance is \n   a) Held as-is in memory for using during chunk tesselation (you can get a reference to it through getDefaultBlockMesh())\n   b) \"Compiled\" to a Model for use during rendering in the gui. \n      Model Compilation means all it's mesh data is uploaded onto the graphcis through a VAO and a ModelRef instance is left behind which\n      can be used by the RenderAPI to render it.",
      "x-abstract": true
    },
    "IBlockTextureAtlasAPI": {
      "type": "object",
      "description": "Block texture Atlas",
      "x-abstract": true
    },
    "IItemTextureAtlasAPI": {
      "type": "object",
      "description": "Item texture Atlas.",
      "x-abstract": true
    },
    "ITextureAtlasAPI": {
      "type": "object",
      "description": "Entity texture Atlas.",
      "x-abstract": true,
      "properties": {
        "unknownTexturePosition": {
          "description": "The texture atlas position of the \"unknown.png\" texture",
          "oneOf": [
            {
              "$ref": "#/definitions/TextureAtlasPosition"
            }
          ]
        },
        "size": {
          "description": "Size of one block texture atlas",
          "oneOf": [
            {
              "$ref": "#/definitions/Size2i"
            }
          ]
        },
        "subPixelPaddingX": {
          "type": "number",
          "description": "As configured in the clientsettings.json divided by the texture atlas size",
          "format": "float"
        },
        "subPixelPaddingY": {
          "type": "number",
          "format": "float"
        },
        "positions": {
          "type": "array",
          "description": "Returns the default texture atlas position for all blocks, referenced  by the texturesubid",
          "items": {
            "$ref": "#/definitions/TextureAtlasPosition"
          }
        },
        "atlasTextureIds": {
          "type": "array",
          "description": "Returns the list of currently loaded texture atlas ids",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "TextureAtlasPosition": {
      "type": "object",
      "description": "The position of a texture inside an atlas",
      "properties": {
        "atlasTextureId": {
          "type": "integer",
          "description": "The OpenGL textureid",
          "format": "int32"
        },
        "atlasNumber": {
          "type": "integer",
          "description": "A sequential number in which atlas this position is in. Atlasses for a given type are sequentially numbered if more than one atlas was required to hold all the textures",
          "format": "int32"
        },
        "avgColor": {
          "type": "integer",
          "format": "int32"
        },
        "rndColors": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "x1": {
          "type": "number",
          "description": "The x coordinate of the texture origin point",
          "format": "float"
        },
        "y1": {
          "type": "number",
          "description": "The y coordinate of the texture origin point",
          "format": "float"
        },
        "x2": {
          "type": "number",
          "description": "The x coordinate of the texture end point",
          "format": "float"
        },
        "y2": {
          "type": "number",
          "description": "The y coordinate of the texture end point",
          "format": "float"
        }
      }
    },
    "IShaderAPI": {
      "type": "object",
      "description": "API for configuring and loading GLSL Shaders",
      "x-abstract": true
    },
    "IClientNetworkAPI": {
      "type": "object",
      "description": "API Features to set up a network channel for custom server&lt;-&gt;client data exchange. Client side.",
      "x-abstract": true
    },
    "IClientWorldAccessor": {
      "type": "object",
      "description": "The world accessor implemented by the client, offers some extra features only available on the client",
      "x-abstract": true,
      "properties": {
        "calendar": {
          "description": "Interface to access the game calendar",
          "oneOf": [
            {
              "$ref": "#/definitions/IClientGameCalendar"
            }
          ]
        },
        "forceLiquidSelectable": {
          "type": "boolean",
          "description": "Whether the player can select liquids"
        },
        "ambientParticles": {
          "type": "boolean",
          "description": "Whether to spawn ambient particles"
        },
        "player": {
          "description": "Returns the player running this client instance",
          "oneOf": [
            {
              "$ref": "#/definitions/IClientPlayer"
            }
          ]
        },
        "loadedEntities": {
          "type": "object",
          "description": "The internal cache of all currently loaded entities. Warning: You should not set or remove anything from this dic unless you *really* know what you're doing. Use SpawnEntity/DespawnEntity instead.",
          "additionalProperties": {
            "$ref": "#/definitions/Entity"
          }
        }
      }
    },
    "IClientGameCalendar": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "sunPositionNormalized": {
          "description": "Returns a normalized vector of the sun position at the players current location",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "sunPosition": {
          "description": "Returns a vector of the sun position at the players current location",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "moonPosition": {
          "description": "Returns a vector of the moon position at the players current location",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "sunColor": {
          "description": "Returns a normalized color of the sun at the players current location",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3f"
            }
          ]
        },
        "sunsetMod": {
          "type": "number",
          "description": "A horizontal offset that is applied when reading the sky glow color at the players current location. Creates a greater variety of sunsets. Changes to a different value once per day (during midnight)",
          "format": "float"
        },
        "dayLightStrength": {
          "type": "number",
          "description": "Returns a value between 0 (no sunlight) and 1 (full sunlight) at the players current location",
          "format": "float"
        },
        "moonLightStrength": {
          "type": "number",
          "description": "Returns a value between 0 (no sunlight) and 1 (full sunlight) at the players current location",
          "format": "float"
        },
        "sunLightStrength": {
          "type": "number",
          "format": "float"
        },
        "dusk": {
          "type": "boolean",
          "description": "If true, its currently dusk at the players current location"
        }
      }
    },
    "IClientPlayer": {
      "type": "object",
      "description": "A client side player",
      "x-abstract": true,
      "properties": {
        "cameraYaw": {
          "type": "number",
          "description": "The cameras current yaw",
          "format": "float"
        },
        "cameraPitch": {
          "type": "number",
          "description": "The cameras current pitch",
          "format": "float"
        },
        "cameraMode": {
          "description": "The players current camera mode",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumCameraMode"
            }
          ]
        }
      }
    },
    "IMusicTrack": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the track"
        },
        "isActive": {
          "type": "boolean",
          "description": "Is the track active?"
        },
        "priority": {
          "type": "number",
          "description": "The priority of the track. A higher priority will cancel active tracks.",
          "format": "float"
        },
        "startPriority": {
          "type": "number",
          "description": "The start priority of the track. A higher priority will leave active tracks playing.",
          "format": "float"
        },
        "positionString": {
          "type": "string"
        }
      }
    },
    "Shape": {
      "type": "object",
      "description": "The base shape for all json objects.",
      "properties": {
        "textures": {
          "type": "object",
          "description": "The collection of textures in the shape.",
          "additionalProperties": {
            "type": "string"
          }
        },
        "elements": {
          "type": "array",
          "description": "The elements of the shape.",
          "items": {
            "$ref": "#/definitions/ShapeElement"
          }
        },
        "animations": {
          "type": "array",
          "description": "The animations for the shape.",
          "items": {
            "$ref": "#/definitions/Animation"
          }
        },
        "animationsByCrc32": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Animation"
          }
        },
        "textureWidth": {
          "type": "integer",
          "description": "The width of the texture. (default: 16)",
          "format": "int32"
        },
        "textureHeight": {
          "type": "integer",
          "description": "The height of the texture (default: 16) ",
          "format": "int32"
        },
        "textureSizes": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "jointsById": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/AnimationJoint"
          }
        },
        "attachmentPointsByCode": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/AttachmentPoint"
          }
        }
      }
    },
    "AnimationJoint": {
      "type": "object",
      "properties": {
        "jointId": {
          "type": "integer",
          "description": "The ID of the joint.",
          "format": "int32"
        },
        "element": {
          "description": "The attached ShapeElement.",
          "oneOf": [
            {
              "$ref": "#/definitions/ShapeElement"
            }
          ]
        }
      }
    },
    "EntityServerProperties": {
      "allOf": [
        {
          "$ref": "#/definitions/EntitySidedProperties"
        },
        {
          "type": "object",
          "properties": {
            "attributes": {
              "type": "array",
              "description": "The attributes of the entity.",
              "items": {}
            },
            "spawnConditions": {
              "description": "The conditions for spawning the entity.",
              "oneOf": [
                {
                  "$ref": "#/definitions/SpawnConditions"
                }
              ]
            }
          }
        }
      ]
    },
    "SpawnConditions": {
      "type": "object",
      "description": "The spawn conditions assigned to various things.",
      "properties": {
        "runtime": {
          "description": "Runtime requirements for the object to spawn.",
          "oneOf": [
            {
              "$ref": "#/definitions/RuntimeSpawnConditions"
            }
          ]
        },
        "worldgen": {
          "description": "Worldgen/region requirements for the object to spawn.",
          "oneOf": [
            {
              "$ref": "#/definitions/WorldGenSpawnConditions"
            }
          ]
        }
      }
    },
    "RuntimeSpawnConditions": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSpawnConditions"
        },
        {
          "type": "object",
          "properties": {
            "chance": {
              "type": "number",
              "description": "The chance for the object to spawn.",
              "format": "double"
            },
            "maxQuantity": {
              "type": "integer",
              "description": "The max quantity of objects to spawn.",
              "format": "int32"
            },
            "minDistanceToPlayer": {
              "type": "integer",
              "description": "The minimum distance from the player that an object will spawn.",
              "format": "int32"
            }
          }
        }
      ]
    },
    "BaseSpawnConditions": {
      "type": "object",
      "properties": {
        "group": {
          "type": "string",
          "description": "The group of the spawn conditions."
        },
        "minLightLevel": {
          "type": "integer",
          "description": "The minimum light level for an object to spawn.",
          "format": "int32"
        },
        "maxLightLevel": {
          "type": "integer",
          "description": "The maximum light level for an object to spawn.",
          "format": "int32"
        },
        "lightLevelType": {
          "description": "The type of light counted for spawning purposes.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumLightLevelType"
            }
          ]
        },
        "herdSize": {
          "description": "the group size for the spawn.",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        },
        "companions": {
          "type": "array",
          "description": "Additional companions for the spawn.",
          "items": {
            "type": "string"
          }
        },
        "insideBlockCodes": {
          "type": "array",
          "description": "The blocks that the object will spawn in.  (default: air)",
          "items": {
            "type": "string"
          }
        },
        "requireSolidGround": {
          "type": "boolean",
          "description": "Checks to see if the object requires solid ground."
        },
        "tryOnlySurface": {
          "type": "boolean",
          "description": "checks to see if the object can only spawn in the surface."
        },
        "climateValueMode": {
          "description": "Whether the rain and temperature values are referring to the worldgen values (i.e. yearly averages) or the current values at the moment of spawning",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumGetClimateMode"
            }
          ]
        },
        "minTemp": {
          "type": "number",
          "description": "The minimum tempurature for the object to spawn.",
          "format": "float"
        },
        "maxTemp": {
          "type": "number",
          "description": "The maximum tempurature for the object to spawn.",
          "format": "float"
        },
        "minRain": {
          "type": "number",
          "description": "The minimum amount of rain for the object to spawn.",
          "format": "float"
        },
        "maxRain": {
          "type": "number",
          "description": "The maximum amount of rain for the object to spawn.",
          "format": "float"
        },
        "minForest": {
          "type": "number",
          "description": "The minimum amount of forest cover needed for the object to spawn.",
          "format": "float"
        },
        "maxForest": {
          "type": "number",
          "description": "The maximum amount of forest cover needed for the object to spawn.",
          "format": "float"
        },
        "minShrubs": {
          "type": "number",
          "description": "The minimum amount of shrubbery needed for the object to spawn.",
          "format": "float"
        },
        "maxShrubs": {
          "type": "number",
          "description": "The maximum amount of shrubbery needed for the object to spawn.",
          "format": "float"
        },
        "minY": {
          "type": "number",
          "description": "Won't span below minY. 0...1 is world bottom to sea level, 1...2 is sea level to world top",
          "format": "float"
        },
        "maxY": {
          "type": "number",
          "description": "Won't span above maxY. 0...1 is world bottom to sea level, 1...2 is sea level to world top",
          "format": "float"
        },
        "minForestOrShrubs": {
          "type": "number",
          "description": "The minimum amount of forest or shrubs for the object to spawn.",
          "format": "float"
        },
        "groupSize": {
          "x-deprecated": true,
          "x-deprecatedMessage": "Use HerdSize instead",
          "oneOf": [
            {
              "$ref": "#/definitions/NatFloat"
            }
          ]
        }
      }
    },
    "EnumLightLevelType": {
      "type": "string",
      "description": "Used in blockAccessor.GetLightLevel() to determine what kind of light level you want",
      "x-enumNames": [
        "OnlyBlockLight",
        "OnlySunLight",
        "MaxLight",
        "MaxTimeOfDayLight",
        "TimeOfDaySunLight"
      ],
      "enum": [
        "onlyBlockLight",
        "onlySunLight",
        "maxLight",
        "maxTimeOfDayLight",
        "timeOfDaySunLight"
      ]
    },
    "EnumGetClimateMode": {
      "type": "string",
      "description": "The type of climate values you wish to receive",
      "x-enumNames": [
        "WorldGenValues",
        "NowValues",
        "ForSuppliedDateValues"
      ],
      "enum": [
        "worldGenValues",
        "nowValues",
        "forSuppliedDateValues"
      ]
    },
    "WorldGenSpawnConditions": {
      "allOf": [
        {
          "$ref": "#/definitions/BaseSpawnConditions"
        },
        {
          "type": "object",
          "properties": {
            "triesPerChunk": {
              "description": "The amount of time the object will attempt to spawn per chunk.",
              "oneOf": [
                {
                  "$ref": "#/definitions/NatFloat"
                }
              ]
            }
          }
        }
      ]
    },
    "GridRecipe": {
      "type": "object",
      "description": "Represents a crafting recipe",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Set by the recipe loader during json deserialization, if false the recipe will never be loaded.\nIf loaded however, you can use this field to disable recipes during runtime."
        },
        "ingredientPattern": {
          "type": "string",
          "description": "The pattern of the ingredient. Order for a 3x3 recipe: \n1 2 3\n4 5 6\n7 8 9\nOrder for a 2x2 recipe:\n1 2\n3 4"
        },
        "ingredients": {
          "type": "object",
          "description": "The recipes ingredients in any order",
          "additionalProperties": {
            "$ref": "#/definitions/CraftingRecipeIngredient"
          }
        },
        "width": {
          "type": "integer",
          "description": "Required grid width for crafting this recipe ",
          "format": "int32"
        },
        "height": {
          "type": "integer",
          "description": "Required grid height for crafting this recipe ",
          "format": "int32"
        },
        "recipeGroup": {
          "type": "integer",
          "description": "Info used by the handbook. Allows you to split grid recipe previews into multiple.",
          "format": "int32"
        },
        "output": {
          "description": "The resulting Stack",
          "oneOf": [
            {
              "$ref": "#/definitions/CraftingRecipeIngredient"
            }
          ]
        },
        "shapeless": {
          "type": "boolean",
          "description": "Whether the order of input items should be respected"
        },
        "name": {
          "type": "string",
          "description": "Name of the recipe, optional"
        },
        "attributes": {
          "description": "Optional attributes",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonObject"
            }
          ]
        },
        "requiresTrait": {
          "type": "string",
          "description": "If set only players with given trait can use this recipe"
        },
        "resolvedIngredients": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CraftingRecipeIngredient"
          }
        }
      }
    },
    "CraftingRecipeIngredient": {
      "type": "object",
      "description": "A crafting recipe ingredient",
      "properties": {
        "type": {
          "description": "Item or Block",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumItemClass"
            }
          ]
        },
        "quantity": {
          "type": "integer",
          "description": "How much input items are required",
          "format": "int32"
        },
        "attributes": {
          "description": "What attributes this itemstack must have",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonObject"
            }
          ]
        },
        "isTool": {
          "type": "boolean",
          "description": "Whether this crafting recipe ingredient should be regarded as a tool required to build this item.\nIf true, the recipe will not consume the item but reduce its durability."
        },
        "toolDurabilityCost": {
          "type": "integer",
          "description": "If IsTool is set, this is the durability cost",
          "format": "int32"
        },
        "allowedVariants": {
          "type": "array",
          "description": "When using a wildcard in the item/block code, setting this field will limit the allowed variants",
          "items": {
            "type": "string"
          }
        },
        "returnedStack": {
          "description": "If set, the crafting recipe will give back the consumed stack to be player upon crafting",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        },
        "resolvedItemstack": {
          "description": "The itemstack made from Code, Quantity and Attributes, populated by the engine",
          "oneOf": [
            {
              "$ref": "#/definitions/ItemStack"
            }
          ]
        },
        "isWildCard": {
          "type": "boolean",
          "description": "Whether this recipe contains a wildcard, populated by the engine"
        },
        "code": {
          "type": "string",
          "description": "Code of the item or block"
        },
        "name": {
          "type": "string",
          "description": "Name of the class, used for filling placeholders in the output stack"
        }
      }
    },
    "AlloyRecipe": {
      "type": "object",
      "properties": {
        "ingredients": {
          "type": "array",
          "description": "The ingredients for this alloy.",
          "items": {
            "$ref": "#/definitions/MetalAlloyIngredient"
          }
        },
        "output": {
          "description": "The output for the alloy.",
          "oneOf": [
            {
              "$ref": "#/definitions/JsonItemStack"
            }
          ]
        },
        "enabled": {
          "type": "boolean"
        }
      }
    },
    "MetalAlloyIngredient": {
      "allOf": [
        {
          "$ref": "#/definitions/JsonItemStack"
        },
        {
          "type": "object",
          "properties": {
            "minRatio": {
              "type": "number",
              "format": "float"
            },
            "maxRatio": {
              "type": "number",
              "format": "float"
            }
          }
        }
      ]
    },
    "SmithingRecipe": {
      "allOf": [
        {
          "$ref": "#/definitions/LayeredVoxelRecipeOfSmithingRecipe"
        },
        {
          "type": "object",
          "properties": {
            "quantityLayers": {
              "type": "integer",
              "format": "int32"
            },
            "recipeCategoryCode": {
              "type": "string"
            }
          }
        }
      ]
    },
    "LayeredVoxelRecipeOfSmithingRecipe": {
      "allOf": [
        {
          "$ref": "#/definitions/RecipeBaseOfSmithingRecipe"
        },
        {
          "type": "object",
          "x-abstract": true,
          "properties": {
            "pattern": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "voxels": {
              "type": "array",
              "items": {
                "type": "boolean"
              }
            }
          }
        }
      ]
    },
    "RecipeBaseOfSmithingRecipe": {
      "type": "object",
      "description": "Creates a new base recipe type.  ",
      "x-abstract": true,
      "properties": {
        "recipeId": {
          "type": "integer",
          "format": "int32"
        },
        "ingredients": {
          "type": "array",
          "description": "...or alternatively for recipes with multiple ingredients",
          "items": {
            "$ref": "#/definitions/CraftingRecipeIngredient"
          }
        },
        "output": {
          "$ref": "#/definitions/JsonItemStack"
        },
        "ingredient": {
          "$ref": "#/definitions/CraftingRecipeIngredient"
        },
        "name": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      }
    },
    "KnappingRecipe": {
      "allOf": [
        {
          "$ref": "#/definitions/LayeredVoxelRecipeOfKnappingRecipe"
        },
        {
          "type": "object",
          "properties": {
            "quantityLayers": {
              "type": "integer",
              "format": "int32"
            },
            "recipeCategoryCode": {
              "type": "string"
            }
          }
        }
      ]
    },
    "LayeredVoxelRecipeOfKnappingRecipe": {
      "allOf": [
        {
          "$ref": "#/definitions/RecipeBaseOfKnappingRecipe"
        },
        {
          "type": "object",
          "x-abstract": true,
          "properties": {
            "pattern": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "voxels": {
              "type": "array",
              "items": {
                "type": "boolean"
              }
            }
          }
        }
      ]
    },
    "RecipeBaseOfKnappingRecipe": {
      "type": "object",
      "description": "Creates a new base recipe type.  ",
      "x-abstract": true,
      "properties": {
        "recipeId": {
          "type": "integer",
          "format": "int32"
        },
        "ingredients": {
          "type": "array",
          "description": "...or alternatively for recipes with multiple ingredients",
          "items": {
            "$ref": "#/definitions/CraftingRecipeIngredient"
          }
        },
        "output": {
          "$ref": "#/definitions/JsonItemStack"
        },
        "ingredient": {
          "$ref": "#/definitions/CraftingRecipeIngredient"
        },
        "name": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      }
    },
    "ClayFormingRecipe": {
      "allOf": [
        {
          "$ref": "#/definitions/LayeredVoxelRecipeOfClayFormingRecipe"
        },
        {
          "type": "object",
          "properties": {
            "quantityLayers": {
              "type": "integer",
              "format": "int32"
            },
            "recipeCategoryCode": {
              "type": "string"
            }
          }
        }
      ]
    },
    "LayeredVoxelRecipeOfClayFormingRecipe": {
      "allOf": [
        {
          "$ref": "#/definitions/RecipeBaseOfClayFormingRecipe"
        },
        {
          "type": "object",
          "x-abstract": true,
          "properties": {
            "pattern": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "voxels": {
              "type": "array",
              "items": {
                "type": "boolean"
              }
            }
          }
        }
      ]
    },
    "RecipeBaseOfClayFormingRecipe": {
      "type": "object",
      "description": "Creates a new base recipe type.  ",
      "x-abstract": true,
      "properties": {
        "recipeId": {
          "type": "integer",
          "format": "int32"
        },
        "ingredients": {
          "type": "array",
          "description": "...or alternatively for recipes with multiple ingredients",
          "items": {
            "$ref": "#/definitions/CraftingRecipeIngredient"
          }
        },
        "output": {
          "$ref": "#/definitions/JsonItemStack"
        },
        "ingredient": {
          "$ref": "#/definitions/CraftingRecipeIngredient"
        },
        "name": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      }
    },
    "BarrelRecipe": {
      "type": "object",
      "properties": {
        "recipeId": {
          "type": "integer",
          "format": "int32"
        },
        "ingredients": {
          "type": "array",
          "description": "...or alternatively for recipes with multiple ingredients",
          "items": {
            "$ref": "#/definitions/BarrelRecipeIngredient"
          }
        },
        "output": {
          "$ref": "#/definitions/JsonItemStack"
        },
        "code": {
          "type": "string"
        },
        "sealHours": {
          "type": "number",
          "format": "double"
        },
        "name": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      }
    },
    "BarrelRecipeIngredient": {
      "allOf": [
        {
          "$ref": "#/definitions/CraftingRecipeIngredient"
        },
        {
          "type": "object",
          "properties": {
            "consumeQuantity": {
              "type": [
                "integer",
                "null"
              ],
              "description": "If set, the barrel may contain more, but it gets consumed by this amount",
              "format": "int32"
            }
          }
        }
      ]
    },
    "IPlayer": {
      "type": "object",
      "description": "Represents a player",
      "x-abstract": true,
      "properties": {
        "entitlements": {
          "type": "array",
          "description": "List of the users entitlements, vanilla servers will list VIV and/or VS Team member entitlements",
          "items": {
            "$ref": "#/definitions/Entitlement"
          }
        },
        "currentBlockSelection": {
          "description": "The block the player is currently aiming at",
          "oneOf": [
            {
              "$ref": "#/definitions/BlockSelection"
            }
          ]
        },
        "currentEntitySelection": {
          "description": "The entity the player is currently aiming at",
          "oneOf": [
            {
              "$ref": "#/definitions/EntitySelection"
            }
          ]
        },
        "playerName": {
          "type": "string",
          "description": "Get the players character name. The character name can be changed every 60 days in the account manager, so don't consider the players name as a unique identifier for a player. Use PlayerUID instead"
        },
        "playerUID": {
          "type": "string",
          "description": "Returns the players identifier that is unique across all registered players and will never change. Use this to uniquely identify a player for all eternity. Shorthand for WorldData.PlayerUID"
        },
        "clientId": {
          "type": "integer",
          "description": "The players current client id, 0 if not connected. This is the number thats assigned by the server for any connecting player. You probably don't need this number.",
          "format": "int32"
        },
        "entity": {
          "description": "The entity the player currently controls",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityPlayer"
            }
          ]
        },
        "worldData": {
          "description": "Some world-specific information about the player. This object is stored with the save game.\nIf you modify it server side, be sure to call player.BroadcastPlayerData() to send it to affected clients.",
          "oneOf": [
            {
              "$ref": "#/definitions/IWorldPlayerData"
            }
          ]
        },
        "inventoryManager": {
          "description": "Returns the given players inventory manager that let's you do various interesting things with the players inventory.",
          "oneOf": [
            {
              "$ref": "#/definitions/IPlayerInventoryManager"
            }
          ]
        },
        "privileges": {
          "type": "array",
          "description": "The list of privileges the player currently has access to (by role or direct assignment)\nThis list is available for the playing player on the client, but not for other players.",
          "items": {
            "type": "string"
          }
        },
        "immersiveFpMode": {
          "type": "boolean"
        }
      }
    },
    "Entitlement": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "BlockSelection": {
      "type": "object",
      "description": "Contains all the information for a players block selection event",
      "properties": {
        "position": {
          "description": "The position the player wants to place/break something at",
          "oneOf": [
            {
              "$ref": "#/definitions/BlockPos"
            }
          ]
        },
        "face": {
          "description": "The face the player aimed at",
          "oneOf": [
            {
              "$ref": "#/definitions/BlockFacing"
            }
          ]
        },
        "hitPosition": {
          "description": "The coordinate of the exact aimed position, relative to the Block Position",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "selectionBoxIndex": {
          "type": "integer",
          "description": "Which selection box was aimed at. The index corresponds to the array returned by Block.GetSelectionBoxes()",
          "format": "int32"
        },
        "didOffset": {
          "type": "boolean",
          "description": "Always false during block use. True during placement if the Position value was offseted. Example:\n- When trying to place planks while aiming at rock, the Position is the one in front of the Rock and DidOffset is True\n- When trying to place planks while aiming at tallgrass, the Position is where the tall grass is and DidOffset is false (because tallgrass is replacable)"
        }
      }
    },
    "EntitySelection": {
      "type": "object",
      "properties": {
        "entity": {
          "description": "The selected Entity.",
          "oneOf": [
            {
              "$ref": "#/definitions/Entity"
            }
          ]
        },
        "position": {
          "description": "The position of the selected entity.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "face": {
          "description": "the facing of the entity.",
          "oneOf": [
            {
              "$ref": "#/definitions/BlockFacing"
            }
          ]
        },
        "hitPosition": {
          "description": "The hit position of the entity.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        }
      }
    },
    "EntityPlayer": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityHumanoid"
        },
        {
          "type": "object",
          "properties": {
            "previousBlockSelection": {
              "description": "The block position previously selected by the player",
              "oneOf": [
                {
                  "$ref": "#/definitions/BlockPos"
                }
              ]
            },
            "blockSelection": {
              "description": "The block or blocks currently selected by the player",
              "oneOf": [
                {
                  "$ref": "#/definitions/BlockSelection"
                }
              ]
            },
            "entitySelection": {
              "description": "The entity or entities selected by the player",
              "oneOf": [
                {
                  "$ref": "#/definitions/EntitySelection"
                }
              ]
            },
            "deathReason": {
              "description": "The reason the player died (if the player did die). Set only by the game server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/DamageSource"
                }
              ]
            },
            "cameraPos": {
              "description": "The camera position of the player's view. Set only by the game client.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Vec3d"
                }
              ]
            },
            "walkYaw": {
              "type": "number",
              "description": "The yaw the player currently wants to walk towards to. Value set by the PlayerPhysics system. Set by the game client and server.",
              "format": "float"
            },
            "walkPitch": {
              "type": "number",
              "description": "The pitch the player currently wants to move to. Only relevant while swimming. Value set by the PlayerPhysics system. Set by the game client and server.",
              "format": "float"
            },
            "onFootStep": {
              "description": "Set this to hook into the foot step sound creator thingy. Currently used by the armor system to create armor step sounds. Called by the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/Action2"
                }
              ]
            },
            "onImpact": {
              "description": "Called when the player falls onto the ground. Called by the game client and server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/ActionOfDouble"
                }
              ]
            },
            "onCanSpawnNearby": {
              "description": "Called whenever the game wants to spawn new creatures around the player. Called only by the game server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/CanSpawnNearbyDelegate"
                }
              ]
            },
            "talkUtil": {
              "$ref": "#/definitions/EntityTalkUtil"
            },
            "prevFrameCanStandUp": {
              "type": "boolean"
            },
            "selfClimateCond": {
              "$ref": "#/definitions/ClimateCondition"
            },
            "storeWithChunk": {
              "type": "boolean"
            },
            "playerUID": {
              "type": "string",
              "description": "The player's internal Universal ID. Available on the client and the server."
            },
            "rightHandItemSlot": {
              "description": "The players right hand contents. Available on the client and the server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/ItemSlot"
                }
              ]
            },
            "leftHandItemSlot": {
              "description": "The playres left hand contents. Available on the client and the server.",
              "oneOf": [
                {
                  "$ref": "#/definitions/ItemSlot"
                }
              ]
            },
            "gearInventory": {
              "type": "array",
              "description": "The players wearables. Available on the client and the server.",
              "items": {}
            },
            "lightHsv": {
              "type": "string",
              "format": "byte"
            },
            "alwaysActive": {
              "type": "boolean"
            },
            "shouldDespawn": {
              "type": "boolean"
            },
            "isInteractable": {
              "type": "boolean"
            },
            "ladderFixDelta": {
              "type": "number",
              "format": "double"
            },
            "player": {
              "description": "The base player attached to this EntityPlayer.",
              "oneOf": [
                {
                  "$ref": "#/definitions/IPlayer"
                }
              ]
            }
          }
        }
      ]
    },
    "Action2": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object",
          "description": "A parameterless method"
        }
      ]
    },
    "ActionOfDouble": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "CanSpawnNearbyDelegate": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "EntityTalkUtil": {
      "type": "object",
      "properties": {
        "soundName": {
          "type": "string"
        },
        "talkSpeedModifier": {
          "type": "number",
          "format": "float"
        },
        "pitchModifier": {
          "type": "number",
          "format": "float"
        },
        "volumneModifier": {
          "type": "number",
          "format": "float"
        },
        "idleTalkChance": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "ClimateCondition": {
      "type": "object",
      "properties": {
        "temperature": {
          "type": "number",
          "description": "Between -20 and +40 degrees",
          "format": "float"
        },
        "worldgenRainfall": {
          "type": "number",
          "description": "If you read the now values, you can still get the world gen rain fall from this value",
          "format": "float"
        },
        "worldGenTemperature": {
          "type": "number",
          "description": "If you read the now values, you can still get the world gen temp from this value",
          "format": "float"
        },
        "rainfall": {
          "type": "number",
          "description": "Nomalized value between 0..1. When loading the now values, this is set to the current precipitation value, otherwise to \"yearly averages\" or the values generated during worldgen",
          "format": "float"
        },
        "rainCloudOverlay": {
          "type": "number",
          "format": "float"
        },
        "fertility": {
          "type": "number",
          "description": "Nomalized value between 0..1",
          "format": "float"
        },
        "forestDensity": {
          "type": "number",
          "description": "Nomalized value between 0..1",
          "format": "float"
        },
        "shrubDensity": {
          "type": "number",
          "description": "Nomalized value between 0..1",
          "format": "float"
        }
      }
    },
    "ItemSlot": {
      "type": "object",
      "description": "The default item slot to item stacks",
      "properties": {
        "backgroundIcon": {
          "type": "string",
          "description": "Icon name to be drawn in the slot background"
        },
        "hexBackgroundColor": {
          "type": "string",
          "description": "If set will be used as the background color"
        },
        "maxSlotStackSize": {
          "type": "integer",
          "description": "The upper holding limit of the slot itself. Standard slots are only limited by the item stacks maxstack size.",
          "format": "int32"
        },
        "inventory": {
          "type": "array",
          "description": "Gets the inventory attached to this ItemSlot.",
          "items": {
            "$ref": "#/definitions/ItemSlot"
          }
        },
        "drawUnavailable": {
          "type": "boolean"
        },
        "itemstack": {
          "description": "The ItemStack contained within the slot.",
          "oneOf": [
            {
              "$ref": "#/definitions/ItemStack"
            }
          ]
        },
        "stackSize": {
          "type": "integer",
          "description": "The number of items in the stack.",
          "format": "int32"
        },
        "empty": {
          "type": "boolean",
          "description": "Whether or not the stack is empty."
        },
        "storageType": {
          "description": "The storage type of this slot.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumItemStorageFlags"
            }
          ]
        }
      }
    },
    "EntityHumanoid": {
      "allOf": [
        {
          "$ref": "#/definitions/EntityAgent"
        },
        {
          "type": "object"
        }
      ]
    },
    "EntityAgent": {
      "allOf": [
        {
          "$ref": "#/definitions/Entity"
        },
        {
          "type": "object",
          "description": "An autonomous, goal-directed entity which observes and acts upon an environment",
          "properties": {
            "headYaw": {
              "type": "number",
              "description": "The yaw of the agents head",
              "format": "float"
            },
            "headPitch": {
              "type": "number",
              "description": "The pitch of the agents head",
              "format": "float"
            },
            "bodyYaw": {
              "type": "number",
              "description": "The yaw of the agents body",
              "format": "float"
            },
            "deadNotify": {
              "type": "boolean",
              "description": "True if all clients have to be informed about this entities death. Set to false once all clients have been notified"
            },
            "currentControls": {
              "$ref": "#/definitions/EnumEntityActivity"
            },
            "allowDespawn": {
              "type": "boolean",
              "description": "Whether or not the entity is allowed to despawn (Default: true)"
            },
            "hideClothing": {
              "type": "boolean"
            },
            "herdId": {
              "type": "integer",
              "description": "Unique identifier for a herd",
              "format": "int64"
            },
            "mountedOn": {
              "$ref": "#/definitions/IMountable"
            },
            "leftHandItemSlot": {
              "description": "Item in the left hand slot of the entity agent.",
              "oneOf": [
                {
                  "$ref": "#/definitions/ItemSlot"
                }
              ]
            },
            "rightHandItemSlot": {
              "description": "Item in the right hand slot of the entity agent.",
              "oneOf": [
                {
                  "$ref": "#/definitions/ItemSlot"
                }
              ]
            },
            "gearInventory": {
              "type": "array",
              "description": "The inventory of the entity agent.",
              "items": {}
            },
            "shouldDespawn": {
              "type": "boolean",
              "description": "Whether or not the entity should despawn."
            },
            "controls": {
              "description": "The controls for this entity.",
              "oneOf": [
                {
                  "$ref": "#/definitions/EntityControls"
                }
              ]
            },
            "serverControls": {
              "description": "The server controls for this entity",
              "oneOf": [
                {
                  "$ref": "#/definitions/EntityControls"
                }
              ]
            },
            "extraTexturesByTextureName": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/CompositeTexture"
              }
            },
            "extraTextureByLocation": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/BakedCompositeTexture"
              }
            }
          }
        }
      ]
    },
    "IMountable": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "mountPosition": {
          "$ref": "#/definitions/Vec3d"
        },
        "mountYaw": {
          "type": [
            "null",
            "number"
          ],
          "format": "float"
        },
        "suggestedAnimation": {
          "type": "string"
        },
        "controls": {
          "description": "Return non-null controls if the player can control the mountable",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityControls"
            }
          ]
        }
      }
    },
    "EntityControls": {
      "type": "object",
      "description": "The available controls to move around a character in a game world",
      "properties": {
        "onAction": {
          "description": "To execute a call handler registered by the engine. Don't use this one, use api.Input.InWorldAction instead.",
          "oneOf": [
            {
              "$ref": "#/definitions/OnEntityAction"
            }
          ]
        },
        "flyMode": {
          "type": "boolean",
          "description": "If true, the entity is either flying or swimming."
        },
        "noClip": {
          "type": "boolean",
          "description": "If true, the entity has NoClip active."
        },
        "flyPlaneLock": {
          "description": "the axis lock for the fly plane.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumFreeMovAxisLock"
            }
          ]
        },
        "walkVector": {
          "description": "Current walking direction.",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "flyVector": {
          "description": "Current flying direction",
          "oneOf": [
            {
              "$ref": "#/definitions/Vec3d"
            }
          ]
        },
        "isFlying": {
          "type": "boolean",
          "description": "Whether or not the entity is flying."
        },
        "isClimbing": {
          "type": "boolean",
          "description": "Whether or not the entity is climbing"
        },
        "isAiming": {
          "type": "boolean",
          "description": "Whether or not the entity is aiming"
        },
        "isStepping": {
          "type": "boolean",
          "description": "Whether or not the entity is currently stepping up a block"
        },
        "handUse": {
          "description": "If the player is currently using the currently held item in a special way (e.g. attacking with smithing hammer or eating an edible item)",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumHandInteract"
            }
          ]
        },
        "handUsingBlockSel": {
          "description": "The block pos the player started using",
          "oneOf": [
            {
              "$ref": "#/definitions/BlockSelection"
            }
          ]
        },
        "usingCount": {
          "type": "integer",
          "format": "int32"
        },
        "usingBeginMS": {
          "type": "integer",
          "format": "int64"
        },
        "leftUsingHeldItemTransformBefore": {
          "$ref": "#/definitions/ModelTransform"
        },
        "usingHeldItemTransformBefore": {
          "$ref": "#/definitions/ModelTransform"
        },
        "usingHeldItemTransformAfter": {
          "$ref": "#/definitions/ModelTransform"
        },
        "movespeedMultiplier": {
          "type": "number",
          "description": "The movement speed multiplier.",
          "format": "float"
        },
        "dirty": {
          "type": "boolean",
          "description": "Whether or not this entity is dirty."
        },
        "flags": {
          "type": "array",
          "items": {
            "type": "boolean"
          }
        },
        "triesToMove": {
          "type": "boolean",
          "description": "Checks to see if the entity is attempting to move in any direction (excluding jumping)"
        },
        "forward": {
          "type": "boolean",
          "description": "A check for if the entity is moving in the direction it's facing."
        },
        "backward": {
          "type": "boolean",
          "description": "A check for if the entity is moving the opposite direction it's facing."
        },
        "left": {
          "type": "boolean",
          "description": "A check to see if the entity is moving left the direction it's facing."
        },
        "right": {
          "type": "boolean",
          "description": "A check to see if the entity is moving right the direction it's facing."
        },
        "jump": {
          "type": "boolean",
          "description": "A check whether to see if the entity is jumping."
        },
        "sneak": {
          "type": "boolean",
          "description": "A check whether to see if the entity is sneaking."
        },
        "sitting": {
          "type": "boolean",
          "description": "A check to see whether the entity is sitting."
        },
        "floorSitting": {
          "type": "boolean",
          "description": "A check to see whether the entity is sitting on the floor."
        },
        "sprint": {
          "type": "boolean",
          "description": "A check to see whether the entity is sprinting."
        },
        "up": {
          "type": "boolean",
          "description": "A check to see whether the entity is moving up."
        },
        "down": {
          "type": "boolean",
          "description": "A check to see whether the entity is moving down."
        },
        "leftMouseDown": {
          "type": "boolean",
          "description": "A check to see if the entity is holding the in-world rleft mouse button down."
        },
        "rightMouseDown": {
          "type": "boolean",
          "description": "A check to see if the entity is holding the in-world right mouse button down."
        }
      }
    },
    "OnEntityAction": {
      "allOf": [
        {
          "$ref": "#/definitions/MulticastDelegate"
        },
        {
          "type": "object"
        }
      ]
    },
    "EnumFreeMovAxisLock": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "None",
        "X",
        "Y",
        "Z"
      ],
      "enum": [
        "none",
        "x",
        "y",
        "z"
      ]
    },
    "EnumHandInteract": {
      "type": "string",
      "description": "",
      "x-enumNames": [
        "None",
        "HeldItemAttack",
        "HeldItemInteract",
        "BlockInteract"
      ],
      "enum": [
        "none",
        "heldItemAttack",
        "heldItemInteract",
        "blockInteract"
      ]
    },
    "IWorldPlayerData": {
      "type": "object",
      "description": "Some world-specific information about a connected player. If you want modify any value, also broadcast the playerdata to all connected clients.\nThis is the object that stored and loaded with the save game",
      "x-abstract": true,
      "properties": {
        "playerUID": {
          "type": "string",
          "description": "The players unique identifier"
        },
        "entityPlayer": {
          "description": "The player entity this player is currently controlling",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityPlayer"
            }
          ]
        },
        "entityControls": {
          "description": "The controls that moves around the EntityPlayer",
          "oneOf": [
            {
              "$ref": "#/definitions/EntityControls"
            }
          ]
        },
        "lastApprovedViewDistance": {
          "type": "integer",
          "description": "The players viewing distance in blocks that is allowed by the server",
          "format": "int32"
        },
        "desiredViewDistance": {
          "type": "integer",
          "description": "The players desired viewing distance in blocks",
          "format": "int32"
        },
        "currentGameMode": {
          "description": "The players current game mode. Will return Spectator mode while the player is connecting.",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumGameMode"
            }
          ]
        },
        "freeMove": {
          "type": "boolean",
          "description": "Whether the player can freely fly around"
        },
        "freeMovePlaneLock": {
          "description": "Whether the player is forcefully kept on vertical or horizontal plane during freemove",
          "oneOf": [
            {
              "$ref": "#/definitions/EnumFreeMovAxisLock"
            }
          ]
        },
        "noClip": {
          "type": "boolean",
          "description": "Affected by collision boxes or not"
        },
        "moveSpeedMultiplier": {
          "type": "number",
          "description": "The players movement speed",
          "format": "float"
        },
        "pickingRange": {
          "type": "number",
          "description": "Range of selectable blox",
          "format": "float"
        },
        "areaSelectionMode": {
          "type": "boolean",
          "description": "Block selection mode"
        }
      }
    },
    "EnumGameMode": {
      "type": "string",
      "description": "A players game mode",
      "x-enumNames": [
        "Guest",
        "Survival",
        "Creative",
        "Spectator"
      ],
      "enum": [
        "guest",
        "survival",
        "creative",
        "spectator"
      ]
    },
    "IPlayerInventoryManager": {
      "type": "object",
      "description": "Let's you do various interesting things with the players inventory.",
      "x-abstract": true,
      "properties": {
        "activeTool": {
          "description": "If the player currently holds a tool in his hands, this value will be set",
          "oneOf": [
            {
              "type": "null"
            },
            {
              "$ref": "#/definitions/EnumTool"
            }
          ]
        },
        "activeHotbarSlotNumber": {
          "type": "integer",
          "description": "The players currently active hot bar slot",
          "format": "int32"
        },
        "activeHotbarSlot": {
          "description": "Returns the currently selected hotbar slot. Might return null if there is no hotbar!",
          "oneOf": [
            {
              "$ref": "#/definitions/ItemSlot"
            }
          ]
        },
        "inventories": {
          "type": "object",
          "description": "List of inventories currently available to the player (may however not be opened)",
          "additionalProperties": {
            "type": "array",
            "items": {}
          }
        },
        "openedInventories": {
          "type": "array",
          "description": "List of inventories currently opened by the player",
          "items": {
            "type": "array",
            "items": {}
          }
        },
        "mouseItemSlot": {
          "description": "Returns the slot that holds the currently dragged itemstack",
          "oneOf": [
            {
              "$ref": "#/definitions/ItemSlot"
            }
          ]
        },
        "currentHoveredSlot": {
          "description": "The slot the player currently hovers over with his mouse cursor",
          "oneOf": [
            {
              "$ref": "#/definitions/ItemSlot"
            }
          ]
        }
      }
    },
    "AABBIntersectionTest": {
      "type": "object",
      "properties": {
        "blockSelectionTester": {
          "$ref": "#/definitions/IWorldIntersectionSupplier"
        },
        "hitPosition": {
          "$ref": "#/definitions/Vec3d"
        },
        "ray": {
          "$ref": "#/definitions/Ray"
        },
        "pos": {
          "$ref": "#/definitions/BlockPos"
        },
        "hitOnBlockFace": {
          "$ref": "#/definitions/BlockFacing"
        },
        "hitOnSelectionBox": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "IWorldIntersectionSupplier": {
      "type": "object",
      "x-abstract": true,
      "properties": {
        "mapSize": {
          "$ref": "#/definitions/Vec3i"
        }
      }
    },
    "Ray": {
      "type": "object",
      "properties": {
        "origin": {
          "$ref": "#/definitions/Vec3d"
        },
        "dir": {
          "$ref": "#/definitions/Vec3d"
        },
        "length": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "CookingRecipeStack": {
      "allOf": [
        {
          "$ref": "#/definitions/JsonItemStack"
        },
        {
          "type": "object",
          "properties": {
            "shapeElement": {
              "type": "string"
            },
            "textureMapping": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "cookedStack": {
              "$ref": "#/definitions/JsonItemStack"
            }
          }
        }
      ]
    }
  }
}